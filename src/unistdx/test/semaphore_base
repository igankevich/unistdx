#ifndef UNISTDX_TEST_SEMAPHORE_BASE
#define UNISTDX_TEST_SEMAPHORE_BASE

#include <condition_variable>
#include <mutex>
#include <queue>
#include <thread>
#include <vector>

#include <gtest/gtest.h>

#include <unistdx/base/types>
#include <unistdx/test/basic_mutex_test>

template <class Q,
          class Mutex,
          class Semaphore=std::condition_variable,
          class Thread=std::thread>
class Thread_pool {

public:
    static constexpr const Q sval = std::numeric_limits<Q>::max();

private:
    std::queue<Q> queue;
    Semaphore cv;
    Mutex mtx;
    bool stopped = false;
    Thread thread;
    Q sum = 0;

public:

    Thread_pool():
        thread{[this] () {
        while (!stopped) {
            Q val = sval;
            {
                std::unique_lock<Mutex> lock(mtx);
                cv.wait(lock, [this] () { return stopped || !queue.empty(); });
                if (stopped) break;
                val = queue.front();
                queue.pop();
            }
            if (val == sval) {
//				std::clog << "Stopping thread pool" << std::endl;
                stopped = true;
            } else {
                sum += val;
            }
        }
    }} {}

    void submit(Q q) {
        {
            std::lock_guard<Mutex> lock(mtx);
            queue.push(q);
        }
        cv.notify_one();
    }

    void wait() {
        if (thread.joinable()) {
            thread.join();
        }
    }

    Q result() const { return sum; }

};

template <class Func>
void run(Func func, unsigned min_threads=2, sys::u64 max_power=10) {
    using sys::u64;
    const auto max_threads = std::max(
        std::thread::hardware_concurrency(),
        2*min_threads);
    for (auto j=min_threads; j<=max_threads; ++j) {
        for (u64 i=0; i<=max_power; ++i) {
            func(j, u64(1) << i);
        }
    }
}

template <class Semaphore>
void test_semaphore_is_available() {
    try {
        Semaphore sem;
        sem.notify_one();
    } catch (const sys::bad_call& err) {
        if (err.errc() != std::errc::function_not_supported) { throw; }
        std::exit(77);
    }
}

template <class Semaphore>
void test_semaphore() {
    typedef std::mutex Mutex;
    {
        try {
            Semaphore sem;
            sem.notify_one();
        } catch (const sys::bad_call& err) {
            if (err.errc() != std::errc::function_not_supported) { throw; }
            std::exit(77);
        }
    }
    run([&] (unsigned nthreads, sys::u64 max) {
        typedef sys::u64 I;
        typedef Thread_pool<I, Mutex, Semaphore> Pool;
        std::vector<std::unique_ptr<Pool>> thread_pool;
        thread_pool.reserve(nthreads);
        for (unsigned i=0; i<nthreads; ++i) {
            thread_pool.emplace_back(new Pool);
        }
        I expected_sum = (max + I(1))*max/I(2);
        for (I i=1; i<=max; ++i) {
            thread_pool[i%thread_pool.size()]->submit(i);
        }
        for (auto& pool : thread_pool) { pool->submit(Pool::sval); }
        for (auto& pool : thread_pool) { pool->wait(); }
        I sum = 0;
        for (const auto& pool : thread_pool) { sum += pool->result(); }
        /*
        for (const auto& pool : thread_pool) {
        	std::cout << pool->result() << std::endl;
        }
        std::cout << max << ": " << sum << std::endl;
        std::clog << "nthreads=" << nthreads << std::endl;
        */
        EXPECT_EQ(expected_sum, sum);
    });
}

#endif // vim:filetype=cpp
