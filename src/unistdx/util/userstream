#ifndef UNISTDX_UTIL_USERSTREAM
#define UNISTDX_UTIL_USERSTREAM

#include <unistdx/bits/no_copy_and_move>
#include <unistdx/it/basic_istream_iterator>
#include <unistdx/util/user>

namespace sys {

	/**
	\brief Input stream of system users.
	\date 2018-05-25
	\author Ivan Gankevich
	\ingroup stream
	\see user
	\see user_iterator
	\details
	Useful to traverse all system users in conjunction with
	\link user_iterator\endlink.
	*/
	class userstream {

    public:
        using iterator = basic_istream_iterator<userstream,user>;
        using value_type = user;
        using reference = value_type&;
        using const_reference = const value_type&;
        using pointer = value_type*;
        using const_pointer = const value_type*;

	private:
		bool _end = false;

	public:

		inline userstream() { this->open(); }
		inline ~userstream() { this->close(); }

		UNISTDX_NO_COPY_AND_MOVE(userstream)

		/// Returns true if the end of stream is not reached.
		inline explicit operator bool() const noexcept { return !this->_end; }

		/// Returns true if the end of stream is reached.
		inline bool operator!() const noexcept { return !this->operator bool(); }

		/// Read the next user from the stream.
		inline userstream& operator>>(reference rhs) {
            if (*this) {
                if (auto u = ::getpwent()) { rhs = *u; }
                else { this->_end = true; }
            }
            return *this;
        }

        inline iterator begin() { return iterator(*this); }
        inline iterator end() { return iterator(); }
        inline void open() { ::setpwent(); }
        inline void close() { ::endpwent(); }

	};

	/// Iterator for \link userstream\endlink.
	using user_iterator = userstream::iterator;

}

#endif // vim:filetype=cpp
