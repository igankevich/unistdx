#ifndef UNISTDX_UTIL_SYSTEM
#define UNISTDX_UTIL_SYSTEM

#include <unistd.h>

/// POSIX and Linux system call wrappers.
namespace sys {

	typedef size_t size_type;

	inline size_type
	page_size() noexcept {
		#if defined(PAGESIZE)
			#define UNISTDX_SYSCONF_PAGE_SIZE PAGESIZE
		#elif defined(PAGE_SIZE)
			#define UNISTDX_SYSCONF_PAGE_SIZE PAGE_SIZE
		#elif defined(_SC_PAGESIZE)
			#define UNISTDX_SYSCONF_PAGE_SIZE _SC_PAGESIZE
		#elif defined(_SC_PAGE_SIZE)
			#define UNISTDX_SYSCONF_PAGE_SIZE _SC_PAGE_SIZE
		#endif
		#if defined(UNISTDX_SYSCONF_PAGE_SIZE)
		long result = ::sysconf(UNISTDX_SYSCONF_PAGE_SIZE);
		return result < 1 ? 4096 : result;
		#else
		return 4096;
		#endif
		#undef UNISTDX_SYSCONF_PAGE_SIZE
	}

	extern unsigned
	thread_concurrency() noexcept;

	inline unsigned
	io_concurrency() noexcept {
		return 1u;
	}

	class cache;

	class cache_level {

	private:
		int _level = 0;
		size_type _size = 0;
		size_type _linesize = 0;
		size_type _assoc = 0;

	public:

		inline int
		level() const noexcept {
			return this->_level;
		}

		inline size_type
		size() const noexcept {
			return this->_size;
		}

		inline size_type
		line_size() const noexcept {
			return this->_linesize;
		}

		inline size_type
		associativity() const noexcept {
			return this->_assoc;
		}

		friend class cache;

	};

	class cache {

	public:
		typedef cache_level value_type;
		typedef const value_type* const_iterator;

	private:
		cache_level _levels[4];
		int _nlevels = 0;

	public:

		cache();
		~cache() = default;

		cache(const cache&) = default;
		cache(cache&&) = default;

		inline int
		num_levels() const noexcept {
			return this->_nlevels;
		}

		inline const_iterator
		begin() const noexcept {
			return this->_levels;
		}

		inline const_iterator
		end() const noexcept {
			return this->_levels + this->_nlevels;
		}

		inline int
		size() const noexcept {
			return this->_nlevels;
		}

		inline value_type
		size(int i) const noexcept {
			return this->_levels[i];
		}

		inline value_type
		operator[](int i) const noexcept {
			return this->_levels[i];
		}

	};

}

#endif // vim:filetype=cpp
