#ifndef UNISTDX_FS_IDIRECTORY
#define UNISTDX_FS_IDIRECTORY

#include <cassert>

#include <unistdx/fs/direntry>
#include <unistdx/fs/dirstream>
#include <unistdx/fs/pathentry>
#include <unistdx/it/basic_istream_iterator>
#include <unistdx/it/iterator_pair>

namespace sys {

	/// Alias to \c DIR system type.
	typedef DIR dir_type;

	/**
	\brief Directory entry input stream.
	\date 2018-05-25
	\author Ivan Gankevich
	\ingroup stream fs
	\tparam FilePred file predicate type, that determines which
	directory entries to include in the stream.
	\see direntry
	\see pathentry
	\details
	An input stream from which directory entries are read non-recursively.
	\arg File predicate may have internal state.
	*/
	template<class FilePred>
	class basic_idirectory: public dirstream {

	public:
		/// File predicate type.
		typedef FilePred filepred_type;

	private:
		path _dirpath;
		dir_type* _dir = nullptr;
		filepred_type _filepred;

	public:

		basic_idirectory() = default;

		/// Construct directory entry input stream for directory \p path.
		inline explicit
		basic_idirectory(const path& path) {
			this->open(path);
		}

		/// Move-constructor.
		inline
		basic_idirectory(basic_idirectory&& rhs):
		dirstream(std::forward<dirstream>(rhs)),
		_dirpath(std::move(rhs._dirpath)),
		_dir(rhs._dir),
		_filepred(std::move(rhs._filepred)) {
			rhs._dir = nullptr;
		}

		basic_idirectory(const basic_idirectory&) = delete;

		inline
		~basic_idirectory() {
			this->close();
		}

		/**
		\brief Open directory \p p as input directory for reading entries.
		\see \man{opendir,3}
		*/
		inline void
		open(const path& p) {
			this->close();
			this->_dirpath = p;
			this->_dir = ::opendir(p);
			if (!this->_dir) {
				this->setstate(failbit);
			}
		}

		/**
		\brief Close input directory.
		\see \man{closedir,3}
		*/
		inline void
		close() {
			if (this->_dir) {
				if (-1 == ::closedir(this->_dir)) {
					this->setstate(failbit);
				}
				this->_dir = nullptr;
			}
		}

		/// Returns true, if the directory was opened.
		inline bool
		is_open() const noexcept {
			return this->_dir != nullptr;
		}

		/// Get file predicate.
		inline const filepred_type&
		getfilepred() const noexcept {
			return this->_filepred;
		}

		/**
		\brief Set file predicate.
		\details
		This method allows for file predicate to have internal state, that
		affects which entries are included in the stream.
		*/
		inline void
		setfilepred(filepred_type rhs) {
			this->_filepred = rhs;
		}

		/// Get input directory.
		inline const path&
		getpath() const noexcept {
			return this->_dirpath;
		}

		/// Get next directory entry as \link direntry\endlink.
		inline basic_idirectory&
		operator>>(direntry& rhs) {
			assert(this->is_open()); // LCOV_EXCL_LINE
			this->read_direntry(rhs);
			return *this;
		}

		/// Get next directory entry as \link pathentry\endlink.
		inline basic_idirectory&
		operator>>(pathentry& rhs) {
			assert(this->is_open()); // LCOV_EXCL_LINE
			this->read_direntry(rhs);
			return *this;
		}

		/// Get all directories entries as a container.
		template <class Entry>
		inline iterator_pair<basic_istream_iterator<basic_idirectory,Entry>>
		entries() noexcept {
			return make_view(
				basic_istream_iterator<basic_idirectory,Entry>(*this),
				basic_istream_iterator<basic_idirectory,Entry>()
			);
		}

	private:

		inline direntry*
		read_direntry() noexcept {
			assert(this->is_open()); // LCOV_EXCL_LINE
			return static_cast<direntry*>(::readdir(this->_dir));
		}

		template<class Entry>
		inline void
		read_direntry(Entry& rhs) {
			assert(this->is_open()); // LCOV_EXCL_LINE
			if (good()) {
				bool success = false;
				while (!success && !this->eof()) {
					const direntry* result = this->read_direntry();
					if (!result) {
						this->setstate(eofbit);
					} else {
						if (this->_filepred(this->_dirpath, *result)) {
							rhs = Entry(this->_dirpath, *result);
							success = true;
						}
					}
				}
			}
		}

		inline void
		read_direntry(direntry& rhs) {
			assert(this->is_open()); // LCOV_EXCL_LINE
			if (this->good()) {
				bool success = false;
				while (!success && !this->eof()) {
					const direntry* result = this->read_direntry();
					if (!result) {
						this->setstate(eofbit);
					} else {
						if (this->_filepred(this->_dirpath, *result)) {
							rhs = *result;
							success = true;
						}
					}
				}
			}
		}

	};

	/**
	\brief Do not include hidden file when traversing directories.
	\date 2018-05-25
	\author Ivan Gankevich
	\ingroup fs
	\details
	This is the default file predicate for \link idirectory\endlink.
	*/
	struct ignore_hidden_files {

		/// Returns true, if directory entry rhs is not hidden.
		template <class Entry>
		inline bool
		operator()(const path&, const Entry& rhs) const noexcept {
			return !rhs.is_hidden();
		}

	};

	/**
	\brief
	Directory entry input stream that ignores all hidden files during traversal.
	\ingroup fs
	*/
	typedef basic_idirectory<ignore_hidden_files> idirectory;

	/// \brief Directory entry input stream iterator.
	/// \ingroup fs
	template<class T>
	using idirectory_iterator = basic_istream_iterator<idirectory, T>;

}

#endif // vim:filetype=cpp
