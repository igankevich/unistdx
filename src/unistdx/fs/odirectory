#ifndef UNISTDX_FS_ODIRECTORY
#define UNISTDX_FS_ODIRECTORY

#include <unistdx/fs/copy_file>
#include <unistdx/fs/idirectory>
#include <unistdx/fs/idirtree>
#include <unistdx/it/basic_ostream_iterator>

namespace sys {

	/**
	\brief Directory entry output stream.
	\date 2018-05-25
	\author Ivan Gankevich
	\ingroup stream
	\tparam Trans transformation function type
	\see direntry
	\see pathentry
	\see copy_file
	\details
	An output stream to which directory entries are written.
	\arg Files are copied to output directory on insertion to the stream.
	*/
	template<class Trans>
	class basic_odirectory {

	public:
		/// File name transformation function type.
		typedef Trans transform;

	private:
		path _dirpath;
		transform _trans;

	public:
		basic_odirectory() = default;

		~basic_odirectory() = default;

		/// Construct directory entry output stream for path \p dir.
		inline explicit
		basic_odirectory(const path& dir):
		_dirpath(dir) {}

		/// Copy-constructor.
		basic_odirectory(const basic_odirectory&) = delete;

		/// Move-constructor.
		basic_odirectory(basic_odirectory&&) = default;

		/// Set directory \p dir as output directory.
		inline void
		open(const path& dir) {
			this->_dirpath = dir;
		}

		/// Get output directory path.
		inline const path&
		getpath() const noexcept {
			return this->_dirpath;
		}

		/// Set file name transformation function.
		inline void
		settransform(transform rhs) {
			this->_trans = rhs;
		}

		/// Get file name transformation function.
		inline const transform&
		gettransform() const noexcept {
			return this->_trans;
		}

		/// Always returns true.
		inline explicit
		operator bool() const noexcept {
			return true;
		}

		/// Always returns false.
		inline bool
		operator!() const noexcept {
			return !this->operator bool();
		}

		/// Copy directory entry \p rhs to output directory of the stream.
		inline basic_odirectory&
		operator<<(const direntry& rhs) {
			copy_file(
				path(rhs.name()),
				path(this->_dirpath, this->_trans(rhs))
			);
			return *this;
		}

		/// Copy directory entry \p rhs to output directory of the stream.
		inline basic_odirectory&
		operator<<(const pathentry& rhs) {
			path p(this->_dirpath, this->_trans(rhs));
			if (get_file_type(rhs) != sys::file_type::directory) {
				copy_file(rhs.getpath(), p);
			} else {
				this->make_directory(p);
			}
			return *this;
		}

		/// Copy all files in directory \p rhs to output directory of the stream.
		template<class FilePred>
		inline basic_odirectory&
		operator<<(basic_idirectory<FilePred>& rhs) {
			pathentry ent;
			while (rhs >> ent) {
				*this << ent;
			}
			return *this;
		}

		/// Recursively copy whole directory \p rhs to output directory of the stream.
		template<class X, class Y>
		inline basic_odirectory&
		operator<<(basic_idirtree<X,Y>& rhs) {
			pathentry ent;
			while (rhs >> ent) {
				*this << ent;
			}
			return *this;
		}

	private:

		inline void
		make_directory(const path& p) {
			UNISTDX_CHECK(::mkdir(p, 0755));
		}

	};

	/**
	\brief Copy files without changing their names.
	\details Default transformation function of directory entry output stream.
	*/
	struct copy_verbatim {

		/// Copy file name of directory \p rhs without changing it.
		template<class Ent>
		inline sys::path
		operator()(const Ent& rhs) const {
			return sys::path(rhs.name());
		}

	};

	/// Directory entry output stream that copies all files verbatim.
	typedef basic_odirectory<copy_verbatim> odirectory;

	/// Directory entry output stream iterator.
	template<class T>
	using odirectory_iterator = basic_ostream_iterator<odirectory, T>;

}

#endif // vim:filetype=cpp
