#ifndef UNISTDX_FS_IDIRTREE
#define UNISTDX_FS_IDIRTREE

#include <queue>

#include <unistdx/fs/idirectory>

namespace sys {

	/**
	\brief Recursive directory entry input stream.
	\date 2018-05-25
	\author Ivan Gankevich
	\ingroup stream fs
	\tparam FilePred file predicate type, that determines which
	directory entries to include in the stream.
	\tparam DirPred directory predicate type, that determines which
	directories to recurse into.
	\see direntry
	\see pathentry
	\details
	An input stream from which directories entries are read recursively.
	\arg File and directory predicates may have internal state.
	*/
	template<class FilePred, class DirPred>
	class basic_idirtree: public basic_idirectory<FilePred> {

	private:
		typedef basic_idirectory<FilePred> base_type;

	public:
		using typename base_type::state;
		using typename base_type::filepred_type;
		using base_type::eofbit;

	public:
		/// Directory predicate type.
		typedef DirPred dirpred_type;

	private:
		std::queue<sys::path> _dirs;
		dirpred_type _dirpred;

	public:

		basic_idirtree() = default;

		/**
		Construct recursive directory entry input stream for
		input directory \p starting_point.
		*/
		inline explicit
		basic_idirtree(const path& starting_point):
		base_type(starting_point) {
			this->_dirs.emplace(starting_point);
		}

		/// Open path \p p as input directory.
		inline void
		open(const path& p) {
			while (!this->_dirs.empty()) {
				this->_dirs.pop();
			}
			base_type::open(p);
			this->_dirs.emplace(p);
		}

		/// Path to the directory which is currently being traversed.
		inline const path&
		current_dir() const noexcept {
			return this->_dirs.front();
		}

		/// Get directory predicate.
		inline const dirpred_type&
		getdirpred() const noexcept {
			return this->_dirpred;
		}

		/// Get directory predicate.
		inline dirpred_type&
		getdirpred() noexcept {
			return this->_dirpred;
		}

		/// Set directory predicate.
		inline void
		setdirpred(dirpred_type rhs) {
			this->_dirpred = rhs;
		}

		/// Get next directory entry as \link direntry\endlink.
		inline basic_idirtree&
		operator>>(direntry& rhs) {
			this->read_direntry(rhs);
			return *this;
		}

		/// Get next directory entry as \link pathentry\endlink.
		inline basic_idirtree&
		operator>>(pathentry& rhs) {
			this->read_direntry(rhs);
			return *this;
		}

	private:

		template<class Entry>
		inline void
		read_direntry(Entry& rhs) {
			bool success = false;
			while (!success && !this->eof()) {
				if (this->base_type::operator>>(rhs)) {
					success = true;
					const path& cur = this->current_dir();
					if (this->_dirpred(cur, rhs)) {
						this->_dirs.emplace(cur, rhs.name());
					}
				} else {
					this->_dirs.pop();
					if (this->_dirs.empty()) {
						this->setstate(eofbit);
					} else {
						this->clear();
						this->base_type::open(this->_dirs.front());
					}
				}
			}
		}

	};

	/**
	\brief Do not recurse to hidden directories when traversing directories.
	\date 2018-05-25
	\author Ivan Gankevich
	\details
	\arg Default directory predicate for \link idirtree\endlink.
	\arg Caches file status, which is accessed with \link status\endlink method.
	\arg File status is updated only if file system does not return file type in
	\link direntry\endlink.
	\ingroup fs
	*/
	struct ignore_hidden_dirs {

	private:
		file_status _stat;
		file_type _type = file_type(DT_UNKNOWN);

	public:

		/// Returns true, if directory entry is not hidden.
		inline bool
		operator()(const path& prefix, const direntry& rhs) {
			return !rhs.is_hidden() && this->type(prefix, rhs) == file_type::directory;
		}

		/// Returns true, if directory entry is not hidden.
		inline bool
		operator()(const path&, const pathentry& rhs) {
			return !rhs.is_hidden() && this->type(rhs) == file_type::directory;
		}

		/// Get file status.
		inline const file_status&
		status() const noexcept {
			return this->_stat;
		}

		/// Get file status.
		inline file_status&
		status() noexcept {
			return this->_stat;
		}

		/// Returns true if file status was queried for the current file.
		inline bool
		has_status() const noexcept {
			return this->_type == file_type(DT_UNKNOWN);
		}

		/// Returns true if file status was not queried for the current file.
		inline bool
		has_type() const noexcept {
			return !this->has_status();
		}

		/// Get or compute file status.
		inline const file_status&
		status(const path& p) {
			if (!this->has_status()) {
				this->_stat.update(p, file_status_flag::no_follow);
			}
			return this->_stat;
		}

	private:

		inline file_type
		type(const path& dirname, const direntry& entry) {
			this->_type = entry.type();
			return entry.has_type()
				? entry.type()
				: this->_stat.update(path(dirname, entry.name()), file_status_flag::no_follow).type();
		}

		inline file_type
		type(const pathentry& entry) {
			return this->type(entry.dirname(), entry);
		}

	};

	/**
	\brief
	Recursive directory entry input stream that ignores all hidden files
	during traversal and does not recurse to hidden directories.
	\ingroup fs
	*/
	typedef basic_idirtree<ignore_hidden_files, ignore_hidden_dirs> idirtree;

	/// \brief Recursive directory entry input stream iterator.
	/// \ingroup fs
	template<class T>
	using idirtree_iterator = basic_istream_iterator<idirtree, T>;

}

#endif // vim:filetype=cpp
