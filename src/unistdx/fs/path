#ifndef UNISTDX_FS_PATH
#define UNISTDX_FS_PATH

#include <memory>
#include <string>

namespace sys {

	/// Path components separator.
	constexpr const char file_separator = '/';

	/// Path separator in environment variables.
	constexpr const char path_separator = ':';

	template <class Ch, class Tr, class Alloc>
	class basic_path;

	template <class Ch, class Tr, class Alloc>
	class basic_canonical_path;

	#define MAKE_OPERATOR(op, tp1, tp2, tp3, tp4) \
	inline friend bool \
	operator op(const tp1 lhs, const tp2 rhs) \
	noexcept( \
		noexcept( \
			::std::operator op( \
				static_cast<const tp3>(lhs), \
				static_cast<const tp4>(rhs) \
			) \
		) \
	) \
	{ \
		return ::std::operator op( \
			static_cast<const tp3>(lhs), \
			static_cast<const tp4>(rhs) \
		); \
	}

	#define MAKE_OPERATOR_EQ(tp1, tp2, tp3, tp4) \
	MAKE_OPERATOR(==, tp1, tp2, tp3, tp4) \
	MAKE_OPERATOR(!=, tp1, tp2, tp3, tp4)

	#define MAKE_OPERATOR_REL(tp1, tp2, tp3, tp4) \
	MAKE_OPERATOR(<, tp1, tp2, tp3, tp4) \
	MAKE_OPERATOR(<=, tp1, tp2, tp3, tp4) \
	MAKE_OPERATOR(>, tp1, tp2, tp3, tp4) \
	MAKE_OPERATOR(>=, tp1, tp2, tp3, tp4)

	/**
	\brief
	File system path template which is a \link std::string\endlink
	with additional methods.
	\date 2018-05-25
	\author Ivan Gankevich
	\ingroup fs
	\tparam Ch character type
	\tparam Tr character traits type
	\tparam Alloc allocator type
	*/
	template <class Ch, class Tr=std::char_traits<Ch>, class Alloc=
				  std::allocator<Ch> >
	class basic_path: public std::basic_string<Ch,Tr,Alloc> {

	public:
		/// String type.
		typedef std::basic_string<Ch,Tr,Alloc> string_type;
		using typename string_type::value_type;
		using typename string_type::traits_type;
		using typename string_type::allocator_type;
		using typename string_type::reference;
		using typename string_type::const_reference;
		using typename string_type::pointer;
		using typename string_type::const_pointer;
		using typename string_type::iterator;
		using typename string_type::const_iterator;
		using typename string_type::reverse_iterator;
		using typename string_type::const_reverse_iterator;
		using typename string_type::difference_type;
		using typename string_type::size_type;

		friend struct std::hash<basic_path>;
		friend class basic_canonical_path<Ch,Tr,Alloc>;

		inline
		basic_path() = default;

		/// Copy-assignment.
		inline basic_path&
		operator=(const basic_path&) = default;

		/// Move-assignment.
		inline basic_path&
		operator=(basic_path&&) = default;

		/// Copy-assignment for string.
		inline basic_path&
		operator=(const string_type& rhs) {
			string_type::operator=(rhs);
			return *this;
		}

		/// Move-assignment for string.
		inline basic_path&
		operator=(string_type&& rhs) {
			string_type::operator=(std::move(rhs));
			return *this;
		}

		/// Assignment.
		inline basic_path&
		operator=(const char* rhs) {
			string_type::operator=(rhs);
			return *this;
		}

		/// Construct path from bar <code>const char*</code>.
		inline explicit
		basic_path(const char* rhs):
		string_type(rhs)
		{}

		/// Copy-constructor for string.
		inline explicit
		basic_path(const string_type& rhs):
		string_type(rhs)
		{}

		/// Move-constructor for string.
		inline explicit
		basic_path(string_type&& rhs) noexcept:
		string_type(std::forward<string_type>(rhs))
		{}

		/// Copy-constructor.
		inline
		basic_path(const basic_path& rhs):
		string_type(rhs)
		{}

		/// Move-constructor.
		inline
		basic_path(basic_path&& rhs):
		string_type(std::forward<string_type>(rhs))
		{}

		/// Construct path from directory \p dir and file \p filename.
		template <class A, class B>
		inline
		basic_path(A&& dir, B&& filename):
		string_type(std::forward<A>(dir)) {
			this->add(std::forward<B>(filename));
		}

		/// Construct path from multiple path components.
		template <class A, class B, class ... Args>
		inline
		basic_path(A&& dir, B&& filename, Args&& ... more_filenames):
		string_type(std::forward<A>(dir)) {
			this->add(
				std::forward<B>(filename),
				std::forward<Args>(more_filenames) ...
			);
		}

		/// Append file \p filename as path component.
		template <class T>
		inline void
		add(T&& filename) {
			this->push_back(file_separator);
			this->append(std::forward<T>(filename));
		}

		/// Append method arguments as path components.
		template <class T, class ... Args>
		inline void
		add(T&& filename, Args&& ... components) {
			this->push_back(file_separator);
			this->append(std::forward<T>(filename));
			this->add(std::forward<Args>(components) ...);
		}

		/**
		Automatically cast to <code>const char*</code> which is oftet used
		in system calls.
		*/
		inline
		operator const value_type*() const noexcept {
			return this->data();
		}

		/// Swap with \p rhs.
		inline void
		swap(basic_path& rhs) {
			std::swap(
				static_cast<string_type&>(*this),
				static_cast<string_type&>(rhs)
			);
		}

		/// \nowarn
		MAKE_OPERATOR_EQ(basic_path&, basic_path&, string_type&, string_type&);
		MAKE_OPERATOR_EQ(basic_path&, string_type&, string_type&, string_type&);
		MAKE_OPERATOR_EQ(string_type&, basic_path&, string_type&, string_type&);
		MAKE_OPERATOR_EQ(basic_path&, char*, string_type&, char*);
		MAKE_OPERATOR_EQ(char*, basic_path&, char*, string_type&);

		MAKE_OPERATOR_REL(basic_path&, basic_path&, string_type&, string_type&);
		MAKE_OPERATOR_REL(basic_path&, string_type&, string_type&, string_type&);
		MAKE_OPERATOR_REL(string_type&, basic_path&, string_type&, string_type&);
		MAKE_OPERATOR_REL(basic_path&, char*, string_type&, char*);
		MAKE_OPERATOR_REL(char*, basic_path&, char*, string_type&);
		/// \endnowarn

	private:

		inline explicit
		basic_path(std::unique_ptr<char[]> rhs):
		string_type(rhs.get())
		{}

	};

	#undef MAKE_OPERATOR
	#undef MAKE_OPERATOR_EQ
	#undef MAKE_OPERATOR_REL

	/// Overload of \link std::swap\endlink for \link basic_path\endlink.
	template <class Ch, class Tr, class Alloc>
	inline void
	swap(basic_path<Ch,Tr,Alloc>& lhs, basic_path<Ch,Tr,Alloc>& rhs) {
		lhs.swap(rhs);
	}

	/**
	\brief
	Specialisation of \link basic_path\endlink for char.
	\ingroup fs
	*/
	typedef basic_path<char> path;

}

namespace std {

	/// Specialisation of \link std::hash\endlink for \link sys::basic_path\endlink.
	template <class Ch, class Tr, class Alloc>
	struct hash<sys::basic_path<Ch,Tr,Alloc> >:
		public std::hash<std::basic_string<Ch,Tr,Alloc>> {

	private:
		typedef std::hash<std::basic_string<Ch,Tr,Alloc>> base_type;

	public:
		/// Hash function return value type.
		typedef size_t result_type;
		/// Hash function argument type.
		typedef sys::basic_path<Ch,Tr,Alloc> argument_type;

		/// Return string hash of path.
		inline result_type
		operator()(const argument_type& rhs) const noexcept {
			return this->base_type::operator()(rhs);
		}

	};

}


#endif // vim:filetype=cpp
