#ifndef UNISTDX_FS_PATHENTRY
#define UNISTDX_FS_PATHENTRY

#include <tuple>

#include <unistdx/fs/direntry>

namespace sys {

	/**
	\brief Directory entry with a path to directory
	\date 2018-05-25
	\author Ivan Gankevich
	\ingroup wrapper fs
	\details
	This class stores a path to a directory where entry is located,
	which makes it convenient for recursive directory traversals.
	*/
	class pathentry: public direntry {

	protected:
		/// Path to a directory containing the entry.
		path _dirname;

	public:

		pathentry() = default;

		/// Copy-constructor.
		pathentry(const pathentry&) = default;

		/// Move-constructor.
		pathentry(pathentry&& rhs) = default;

		~pathentry() = default;

		/// Construct path entry with \p dirname and \p ent.
		inline
		pathentry(const path& dirname, const direntry& ent):
		direntry(ent),
		_dirname(dirname) {}

		/// Directory path.
		inline const path&
		dirname() const noexcept {
			return this->_dirname;
		}

		/// Entry path.
		inline path
		getpath() const {
			return path(this->_dirname, name());
		}

		/// Compare entry paths.
		inline bool
		operator<(const pathentry& rhs) const noexcept {
			return this->dirname() < rhs.dirname() ||
				(this->dirname() == rhs.dirname() &&
				 std::strcmp(this->name(), rhs.name()) < 0);
		}

		/// Compare entry paths.
		inline bool
		operator==(const pathentry& rhs) const noexcept {
			return this->_dirname == rhs._dirname &&
				   !std::strcmp(this->name(), rhs.name());
		}

		/// Compare entry paths.
		inline bool
		operator!=(const pathentry& rhs) const noexcept {
			return !this->operator==(rhs);
		}

		/// Print file path.
		inline friend std::ostream&
		operator<<(std::ostream& out, const pathentry& rhs) {
			return out << rhs.dirname() << file_separator << rhs.name();
		}

		/// Copy-assignment.
		pathentry&
		operator=(const pathentry&) = default;

		/// Move-assignment.
		pathentry&
		operator=(pathentry&& rhs) = default;

	};

	/**
	\brief Reliably get file type of a directory entry.
	\param rhs directory entry
	\details
	Falls back to \link file_stat\endlink if directory entry itself
	does not have valid file type.
	*/
	inline sys::file_type
	get_file_type(const pathentry& rhs) {
		return rhs.has_type()
		       ? rhs.type()
			   : file_stat(rhs.getpath()).type();
	}

}

#endif // vim:filetype=cpp
