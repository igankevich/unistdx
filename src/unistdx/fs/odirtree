#ifndef UNISTDX_FS_ODIRTREE
#define UNISTDX_FS_ODIRTREE

#include <cassert>

#include <unistdx/fs/idirtree>
#include <unistdx/fs/idirectory>
#include <unistdx/fs/odirectory>

namespace sys {

    /// \brief The same template as basic_odirectory.
    /// \ingroup fs
    template <class Trans>
    using basic_odirtree = basic_odirectory<Trans>;

    /**
    \brief Copy files and directories recursively.
    \details
    This is the default file transformation type for
    \link odirtree\endlink.
    \ingroup fs
    */
    struct copy_recursively {

    private:
        path _src;
        path _dest;

    public:

        copy_recursively() = default;

        /**
        Construct transformation with source directory \p src
        and destination directory \p dst.
        */
        inline
        copy_recursively(const path& src, const path& dst):
        _src(src),
        _dest(dst)
        {
            // LCOV_EXCL_START
            assert(!this->_src.empty());
            assert(!this->_dest.empty());
            // LCOV_EXCL_STOP
        }

        /// Copy file name of directory \p rhs without changing it.
        inline sys::path
        operator()(const directory_entry& rhs) const {
            return sys::path(rhs.name());
        }

        /// Copy file name of directory \p rhs without changing it.
        inline sys::path
        operator()(const sys::path& prefix, const directory_entry& rhs) const {
            return make_dirs(sys::path(prefix, rhs.name()));
        }

    private:
        sys::path
        make_dirs(const sys::path& rhs) const;

    };

    /**
    \brief
    Directory entry output stream that copies
    all files and directories recursively.
    \ingroup fs
    */
    typedef basic_odirtree<copy_recursively> odirtree;

    /// \brief Directory entry output stream iterator.
    /// \ingroup fs
    template<class T>
    using odirtree_iterator = basic_ostream_iterator<odirtree, T>;

}

#endif // vim:filetype=cpp
