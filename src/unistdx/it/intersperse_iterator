#ifndef UNISTDX_IT_INTERSPERSE_ITERATOR
#define UNISTDX_IT_INTERSPERSE_ITERATOR

#include <iterator>

namespace sys {

	namespace bits {

		typedef std::iterator<std::output_iterator_tag, void, void, void, void>
			intersperse_iterator_base;

	}

	/**
	\brief Iterator that intersperses output values by specified delimiter.
	\date 2018-05-22
	\author Ivan Gankevich
	\ingroup iter
	\tparam T element type
	\tparam Delim delimiter type
	\tparam Ch character type
	\tparam Tr character traits type
	\details
	\arg The type of delimiter can be set via template parameter.
	*/
	template <class T, class Delim=const char*, class Ch=char, class Tr=
				  std::char_traits<Ch> >
	class intersperse_iterator: public bits::intersperse_iterator_base {

	private:
		typedef bits::intersperse_iterator_base base_type;

	public:
		using typename base_type::iterator_category;
		using typename base_type::value_type;
		using typename base_type::pointer;
		using typename base_type::reference;
		using typename base_type::difference_type;

	public:
		/// Object type.
		typedef T object_type;
		/// Delimiter type.
		typedef Delim delim_type;
		/// Character type.
		typedef Ch char_type;
		/// Character traits type.
		typedef Tr traits_type;
		/// Output stream type.
		typedef std::basic_ostream<Ch,Tr> ostream_type;

	private:
		ostream_type* ostr;
		delim_type delim = nullptr;
		bool first = true;

	public:

		/**
		Construct intersperse iterator with output stream \p s and
		delimiter \p delimiter.
		*/
		inline explicit constexpr
		intersperse_iterator(ostream_type& s, delim_type delimiter=nullptr):
		ostr(&s), delim(delimiter) {}

		inline constexpr
		intersperse_iterator() = default;

		inline
		~intersperse_iterator() = default;

		/// Copy-constructor.
		inline constexpr
		intersperse_iterator(const intersperse_iterator&) = default;

		/// Move-constructor.
		inline intersperse_iterator(intersperse_iterator&& rhs):
		ostr(rhs.ostr), delim(rhs.delim), first(rhs.first) {
			rhs.ostr = nullptr;
		}

		/// Assignment operator.
		inline intersperse_iterator&
		operator=(const intersperse_iterator&) = default;

		/// Insert object \p value in the stream.
		inline intersperse_iterator&
		operator=(const object_type& value) {
			if (ostr) {
				if (delim != 0 && !first) {
					*ostr << delim;
				}
				*ostr << value;
				if (first) {
					first = false;
				}
			}
			return *this;
		}

		/// Does nothing.
		inline intersperse_iterator&
		operator*() {
			return *this;
		}

		/// Does nothing.
		inline intersperse_iterator&
		operator++() {
			return *this;
		}

		/// Does nothing.
		inline intersperse_iterator&
		operator++(int) {
			return *this;
		}

	};


}

#endif // vim:filetype=cpp
