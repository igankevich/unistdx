#ifndef UNISTDX_IO_PIPE
#define UNISTDX_IO_PIPE

#include <unistdx/io/fildes>

namespace sys {

	/**
	\brief A pipe constructed with \man{pipe,2} system call.
	\date 2018-05-23
	\author Ivan Gankevich
	\ingroup io
	\see \man{pipe2,2}
	*/
	union pipe {

	private:
		sys::fildes _fds[2] = {};
		fd_type _rawfds[2];

	public:

		/**
		\brief Construct pipe with \man{pipe,2} system call.
		\throws bad_call
		\see \man{pipe2,2}
		\details
		Both file descriptors are in non-blocking mode
		and have close-on-exec flag set.
		*/
		inline
		pipe(): _fds {} {
			this->open();
		}

		/// Move-constructor.
		inline
		pipe(pipe&& rhs) noexcept:
		_fds {std::move(rhs._fds[0]), std::move(rhs._fds[1])}
		{}

		/// Construct pipe with existing file descriptors.
		inline
		pipe(fd_type in, fd_type out) noexcept:
		_fds {sys::fildes(in), sys::fildes(out)}
		{}

		inline
		~pipe() {}

		/// Input file descriptor.
		inline fildes&
		in() noexcept {
			return this->_fds[0];
		}

		/// Output file descriptor.
		inline fildes&
		out() noexcept {
			return this->_fds[1];
		}

		/// Input file descriptor.
		inline const fildes&
		in() const noexcept {
			return this->_fds[0];
		}

		/// Output file descriptor.
		inline const fildes&
		out() const noexcept {
			return this->_fds[1];
		}

		/**
		\brief Create pipe with \man{pipe,2} system call.
		\throws bad_call
		\see \man{pipe2,2}
		*/
		void open();

		/**
		\brief Close both pipe file descriptors.
		\throws bad_call
		\see \man{close,2}
		*/
		void close();

		friend std::ostream&
		operator<<(std::ostream& out, const pipe& rhs);

		static_assert(sizeof(_fds) == sizeof(_rawfds), "bad sys::fildes size");
	};

	/// Print pipe input and output file descriptors for debugging.
	std::ostream&
	operator<<(std::ostream& out, const pipe& rhs);

}

#endif // vim:filetype=cpp
