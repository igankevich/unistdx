#ifndef UNISTDX_IO_FILDES
#define UNISTDX_IO_FILDES

#include <unistd.h>
#include <fcntl.h>

#include <ostream>

#include <unistdx/config>
#if defined(UNISTDX_HAVE_FIONREAD)
#include <sys/ioctl.h>
#endif

#include <unistdx/base/check>
#include <unistdx/base/streambuf_traits>
#include <unistdx/fs/file_status>
#include <unistdx/io/fd_type>
#include <unistdx/io/open_flag>

#ifndef NDEBUG
#include <iostream>
#endif

namespace sys {

	typedef ::mode_t mode_type;

	/// File descriptor flags.
	enum class fd_flag: int {
		fd_close_on_exec = FD_CLOEXEC
	};

	template <>
	struct is_flag<fd_flag>: public std::true_type {};

	#if defined(UNISTDX_HAVE_F_SETNOSIGPIPE)
	/// File descriptor pipe flags.
	enum class pipe_flag: int {
		no_sigpipe = F_SETNOSIGPIPE
	};

	template <>
	struct is_flag<pipe_flag>: public std::true_type {};
	#endif

	/**
	\brief File descriptor wrapper.
	\date 2018-05-22
	\author Ivan Gankevich
	\ingroup wrapper io
	*/
	class fildes {

	private:
		typedef int flag_type;

	public:

		/// Invalid file descriptor constant.
		static constexpr const fd_type bad = -1;

	protected:
		/// File descriptor number
		fd_type _fd = bad;

	public:

		inline fildes() = default;
		fildes(const fildes&) = delete;
		fildes& operator=(const fildes&) = delete;

		/// Construct file descriptor by wrapping \p rhs.
		inline explicit
		fildes(fd_type rhs) noexcept:
		_fd(rhs)
		{}

		/// Move-constructor.
		inline
		fildes(fildes&& rhs) noexcept: _fd(rhs._fd) {
			rhs._fd = bad;
		}

		/**
		Construct file descriptor by opening file \p filename with
		open flags \p flags and mode \p mode.
		*/
		inline
		fildes(const char* filename, open_flag flags=open_flag(), mode_type mode=0) {
			this->open(filename, flags, mode);
		}

		/**
		\brief Close file descriptor
		\details
		The method ignores errors reported by \man{close,2} system call.
		*/
		inline
		~fildes() {
			this->close();
		}

		/// Move-assignment.
		inline fildes&
		operator=(fildes&& rhs) noexcept {
			this->swap(rhs);
			return *this;
		}

		/**
		\brief Close file descriptor.
		\throws bad_call if \man{close,2} system call fails
		\see \man{close,2}
		*/
		inline void
		close() {
			if (*this) {
				UNISTDX_CHECK(::close(this->_fd));
				this->_fd = bad;
			}
		}

		/**
		\brief Read \p n bytes from file descriptor and store them in the array
		pointed by \p buf.
		\throws_bad_call_non_blocking
		\see \man{read,2}
		*/
		inline ssize_t
		read(void* buf, size_t n) const {
			ssize_t ret = ::read(this->_fd, buf, n);
			UNISTDX_CHECK_IO(ret);
			return ret;
		}

		/**
		\brief Write \p n bytes to file descriptor copying them from the array
		pointer by \p buf.
		\throws_bad_call_non_blocking
		\see \man{write,2}
		*/
		inline ssize_t
		write(const void* buf, size_t n) const {
			ssize_t ret = ::write(this->_fd, buf, n);
			UNISTDX_CHECK_IO(ret);
			return ret;
		}

		/// Get bare file descriptor.
		inline fd_type
		fd() const noexcept {
			return this->_fd;
		}

		/**
		\brief Get file descriptor open flags.
		\throws bad_call
		\see \man{fcntl,2}
		*/
		inline open_flag
		flags() const {
			return open_flag(this->get_flags(F_GETFL));
		}

		/**
		\brief Get file descriptor flags.
		\throws bad_call
		\see \man{fcntl,2}
		*/
		inline fd_flag
		fd_flags() const {
			return fd_flag(this->get_flags(F_GETFD));
		}

		/**
		\brief Set file descriptor open flags.
		\throws bad_call
		\see \man{fcntl,2}
		*/
		inline void
		setf(open_flag rhs) {
			this->set_flag(F_SETFL, flag_type(this->flags() | rhs));
		}

		/**
		\brief Unset file descriptor open flags.
		\throws bad_call
		\see \man{fcntl,2}
		*/
		inline void
		unsetf(open_flag rhs) {
			this->set_flag(F_SETFL, flag_type(this->flags() & ~rhs));
		}

		#if defined(UNISTDX_HAVE_F_SETNOSIGPIPE)
		/**
		\brief Set file descriptor pipe flags.
		\throws bad_call
		\see \man{fcntl,2}
		*/
		inline void
		setf(pipe_flag rhs) {
			this->set_flag(int(rhs), 1);
		}

		/**
		\brief Unset file descriptor pipe flags.
		\throws bad_call
		\see \man{fcntl,2}
		*/
		inline void
		unsetf(pipe_flag rhs) {
			this->set_flag(int(rhs), 0);
		}
		#endif

		/**
		\brief Set file descriptor flags.
		\throws bad_call
		\see \man{fcntl,2}
		*/
		inline void
		setf(fd_flag rhs) {
			this->set_flag(F_SETFD, flag_type(rhs));
		}

		/**
		\brief Unset file descriptor flags.
		\throws bad_call
		\see \man{fcntl,2}
		*/
		inline void
		unsetf(fd_flag rhs) {
			this->set_flag(F_SETFD, flag_type(this->fd_flags() & ~rhs));
		}

		/// Compare file descriptors.
		inline bool
		operator==(const fildes& rhs) const noexcept {
			return this->_fd == rhs._fd;
		}

		/// Compare file descriptors.
		inline bool
		operator!=(const fildes& rhs) const noexcept {
			return !this->operator==(rhs);
		}

		/// Returns true, if file descriptor is valid.
		inline explicit
		operator bool() const noexcept {
			return this->_fd >= 0;
		}

		/// Returns true, if file descriptor is invalid.
		inline bool
		operator !() const noexcept {
			return !this->operator bool();
		}

		/// Output file descriptor number.
		inline friend std::ostream&
		operator<<(std::ostream& out, const fildes& rhs) {
			return out << rhs._fd;
		}

		/// Swap with \p rhs.
		inline void
		swap(fildes& rhs) noexcept {
			std::swap(this->_fd, rhs._fd);
		}

		/**
		\brief
		Change file descriptor number to an arbitrrary one
		by duplicating it with \man{dup,2} system call.
		\throws bad_call
		\see \man{dup,2}
		*/
		void
		remap();

		/**
		\brief
		Change file descriptor number to \p new_fd
		by duplicating it with \man{dup2,2} system call.
		\throws bad_call
		\see \man{dup2,2}
		*/
		void
		remap(fd_type new_fd);

		/**
		\brief
		Check if this file descriptor exists in the kernel
		by trying to get its flags
		\throws bad_call
		*/
		inline void
		validate() {
			this->get_flags(F_GETFD);
		}

		/**
		\brief
		Init file descriptor by opening file \p filename with
		open flags \p flags and mode \p mode.
		\throws bad_call
		*/
		inline void
		open(const char* filename, open_flag flags=open_flag(), mode_type mode=0) {
			this->close();
			this->_fd = ::open(
				filename,
				static_cast<flag_type>(flags|open_flag::close_on_exec),
				mode
			);
			UNISTDX_CHECK(this->_fd);
		}

		/// Get file status for this file descriptor.
		inline file_status
		status() const {
			return file_status{this->_fd};
		}

	private:

		inline flag_type
		get_flags(int which) const {
			int ret;
			UNISTDX_CHECK(ret = ::fcntl(this->_fd, which));
			return ret;
		}

		inline void
		set_flag(int which, flag_type val) {
			UNISTDX_CHECK(::fcntl(this->_fd, which, val));
		}

	};

	static_assert(sizeof(fildes) == sizeof(fd_type), "bad fd size");

	/// Compare file descriptors.
	inline bool
	operator==(fd_type lhs, const fildes& rhs) noexcept {
		return rhs.fd() == lhs;
	}

	/// Compare file descriptors.
	inline bool
	operator==(const fildes& lhs, fd_type rhs) noexcept {
		return lhs.fd() == rhs;
	}

	/// Compare file descriptors.
	inline bool
	operator!=(fd_type lhs, const fildes& rhs) noexcept {
		return !operator==(lhs, rhs);
	}

	/// Compare file descriptors.
	inline bool
	operator!=(const fildes& lhs, fd_type rhs) noexcept {
		return !operator==(lhs, rhs);
	}

	/// Overload of \link std::swap\endlink for \link fildes\endlink.
	inline void
	swap(fildes& lhs, fildes& rhs) noexcept {
		lhs.swap(rhs);
	}

	/**
	\brief
	Base class for File descriptor \link streambuf_traits\endlink.
	\date 2018-05-22
	\author Ivan Gankevich
	\ingroup traits io
	*/
	template<class T>
	struct fildes_streambuf_traits {

		/// Character type.
		typedef void char_type;

		/**
		Write \p n bytes from array pointed by \p s to buffer \p buf.
		*/
		inline static std::streamsize
		write(T& sink, const char_type* s, std::streamsize n) {
			return sink.write(s, n);
		}

		/**
		Read \p n bytes to array pointed by \p s from buffer \p buf.
		*/
		inline static std::streamsize
		read(T& src, char_type* s, std::streamsize n) {
			return src.read(s, n);
		}

		/**
		Determine if file descriptor is in bloking mode
		by checking its flags.
		*/
		inline static bool
		is_blocking(const T& rhs) {
			try {
				return rhs.flags() & open_flag::non_blocking != open_flag::non_blocking;
			} catch (sys::bad_call& err) {
				return false;
			}
		}

		/**
		Determine how many bytes are available for reading from kernel buffer.
		*/
		inline static std::streamsize
		in_avail(T& rhs) {
			#if defined(UNISTDX_HAVE_FIONREAD)
			int nread;
			if (::ioctl(rhs.fd(), FIONREAD, &nread) < 0) {
				nread = 0;
			}
			return nread;
			#else
			return 0;
			#endif
		}

	};

	/**
	\brief
	Stream buffer traits for \link fildes\endlink.
	\date 2018-05-22
	\author Ivan Gankevich
	\ingroup traits io
	*/
	template<>
	struct streambuf_traits<fildes>:
	public fildes_streambuf_traits<fildes>
	{};

	/**
	\brief
	Stream buffer traits for bare \link fd_type\endlink.
	\date 2018-05-22
	\author Ivan Gankevich
	\ingroup traits io
	*/
	template<>
	struct streambuf_traits<fd_type> {

		/// Character type.
		typedef void char_type;

		/**
		Write \p n bytes from array pointed by \p s to file descriptor \p sink.
		*/
		inline static std::streamsize
		write(fd_type sink, const char_type* s, std::streamsize n) {
			ssize_t ret = ::write(sink, s, n);
			UNISTDX_CHECK_IO(ret);
			return ret;
		}

		/**
		Read \p n bytes to array pointed by \p s from file descriptor \p src.
		*/
		inline static std::streamsize
		read(fd_type src, char_type* s, std::streamsize n) {
			ssize_t ret = ::read(src, s, n);
			UNISTDX_CHECK_IO(ret);
			return ret;
		}

	};

}

#endif // vim:filetype=cpp
