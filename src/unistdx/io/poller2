#ifndef UNISTDX_IO_POLLER2
#define UNISTDX_IO_POLLER2

#include <chrono>

#include <unistdx/bits/no_copy_and_move>
#include <unistdx/check>
#include <unistdx/io/epoll_event>
#include <unistdx/io/fildes>
#include <unistdx/io/pipe>

namespace sys {


	template <class Handler>
	class event_poller2 {

	public:
		typedef Handler handler_type;
		typedef std::chrono::steady_clock clock_type;
		template<class Duration>
		using time_point = std::chrono::time_point<clock_type, Duration>;

	private:
		fildes _epollfd;
		/// Notification pipe.
		pipe _pipe;

	public:

		event_poller2():
		_epollfd(::epoll_create1(EPOLL_CLOEXEC)),
		_pipe() {
			this->xadd(this->pipe_in(), event::in);
		}

		~event_poller2() = default;

		UNISTDX_NO_COPY_AND_MOVE(event_poller2);

		inline void
		notify_one() noexcept {
			char c = '!';
			this->_pipe.out().write(&c, sizeof(char));
		}

		inline void
		notify_all() noexcept {
			this->notify_one();
		}

		inline fd_type
		pipe_in() const noexcept {
			return this->_pipe.in().get_fd();
		}

		template<class Lock>
		inline void
		wait(Lock& lock) {
			this->wait(lock, [] () { return false; });
		}

		template<class Lock, class Pred>
		inline void
		wait(Lock& lock, Pred pred) {
			int ret = -1;
			while (ret <= 0 && !pred()) {
				ret = do_poll(lock, no_timeout);
			}
		}

		template<class Lock, class Rep, class Period>
		inline std::cv_status
		wait_for(Lock& lock, const std::chrono::duration<Rep,Period>& dur) {
			using namespace std::chrono;
			const auto d = duration_cast<milliseconds>(dur);
			int ret = do_poll(lock, static_cast<int>(d.count()));
			return ret == 0 ? std::cv_status::timeout :
			       std::cv_status::no_timeout;
		}

		template<class Lock, class Rep, class Period, class Pred>
		inline bool
		wait_for(
			Lock& lock,
			const std::chrono::duration<Rep,Period>& dur,
			Pred pred
		) {
			while (!pred()) {
				if (this->wait_for(lock, dur) == std::cv_status::timeout) {
					return pred();
				}
			}
			return true;
		}

		template<class Lock, class Duration>
		inline std::cv_status
		wait_until(Lock& lock, const time_point<Duration>& tp) {
			return wait_for(
				lock,
				std::max(
					clock_type::duration::zero(),
					tp-
					clock_type::now()
				)
			);
		}

		template<class Lock, class Duration, class Pred>
		bool
		wait_until(Lock& lock, const time_point<Duration>& tp, Pred pred) {
			return wait_for(
				lock,
				std::max(clock_type::duration::zero(), tp-clock_type::now()),
				pred
			);
		}

		template<class Lock, class Clock, class Duration>
		std::cv_status
		wait_until(
			Lock& lock,
			const std::chrono::time_point<Clock, Duration>& tp
		) {
			typedef Clock other_clock;
			const auto delta = tp - other_clock::now();
			const auto new_tp = clock_type::now() + delta;
			return this->wait_until(lock, new_tp);
		}

		template<class Lock, class Clock, class Duration, class Pred>
		inline bool
		wait_until(
			Lock& lock,
			const std::chrono::time_point<Clock, Duration>& tp,
			Pred pred
		) {
			typedef Clock other_clock;
			const auto delta = tp - other_clock::now();
			const auto new_tp = clock_type::now() + delta;
			return this->wait_until(lock, new_tp, pred);
		}

	private:

		void
		xadd(epoll_event ev) {
			UNISTDX_CHECK(
				::epoll_ctl(this->_epollfd.get_fd(), EPOLL_CTL_ADD, ev.fd(), &ev)
			);
		}

		void
		xmod(epoll_event ev) {
			UNISTDX_CHECK(
				::epoll_ctl(this->_epollfd.get_fd(), EPOLL_CTL_MOD, ev.fd(), &ev)
			);
		}

		void
		xdel(fd_type fd) {
			UNISTDX_CHECK(
				::epoll_ctl(this->_epollfd.get_fd(), EPOLL_CTL_DEL, fd, nullptr)
			);
		}

	};

}

#endif // vim:filetype=cpp
