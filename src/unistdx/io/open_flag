#ifndef UNISTDX_IO_OPEN_FLAG
#define UNISTDX_IO_OPEN_FLAG

#include <unistdx/bits/open_flag>

namespace sys {

	/// Raw file descriptor flag type (int).
	typedef int flag_type;

	/**
	\brief Flags used when opening file.
	\date 2018-05-23
	\author Ivan Gankevich
	*/
	class open_flag {

	private:
		flag_type _flag = 0;

	public:
		/// Flags enumeration.
		enum open_flag_enum: flag_type {
			append = O_APPEND,
			async = O_ASYNC,
			close_on_exec = UNISTDX_O_CLOEXEC,
			create = O_CREAT,
			direct = UNISTDX_O_DIRECT,
			directory = UNISTDX_O_DIRECTORY,
			dsync = O_DSYNC,
			exclude = O_EXCL,
			large_file = UNISTDX_O_LARGEFILE,
			no_atime = UNISTDX_O_NOATIME,
			no_ctty = O_NOCTTY,
			no_follow = UNISTDX_O_NOFOLLOW,
			non_blocking = O_NONBLOCK,
			path = UNISTDX_O_PATH,
			read_only = O_RDONLY,
			read_write = O_RDWR,
			rsync = UNISTDX_O_RSYNC,
			sync = O_SYNC,
			tmp_file = UNISTDX_O_TMPFILE,
			truncate = O_TRUNC,
			write_only = O_WRONLY,
		};

		open_flag() = default;

		/// Copy-constructor.
		open_flag(const open_flag&) = default;

		/// Construct open flag from raw flag.
		inline
		open_flag(flag_type rhs) noexcept:
		_flag(rhs)
		{}

		/// Automatically cast to raw flag.
		inline
		operator flag_type() const noexcept {
			return this->_flag;
		}

		/// Returns true, if non-blocking flag is set.
		inline bool
		is_non_blocking() const noexcept {
			return this->_flag & non_blocking;
		}

		/// Returns true, if non-blocking flag is not set.
		inline bool
		is_blocking() const noexcept {
			return !this->is_non_blocking();
		}

	};

	/// Check if flag \p rhs is supported by operating system.
	inline constexpr bool
	supports(open_flag::open_flag_enum rhs) noexcept {
		return flag_type(rhs) != 0;
	}

	#define MAKE_UNARY(op) \
	inline open_flag \
	operator op(open_flag rhs) noexcept { \
		return op flag_type(rhs); \
	}

	#define MAKE_BINARY_1(op, return_type) \
	inline return_type \
	operator op(open_flag lhs, open_flag rhs) noexcept { \
		return flag_type(lhs) op flag_type(rhs); \
	}

	#define MAKE_BINARY_2(op, return_type) \
	inline return_type \
	operator op(flag_type lhs, open_flag rhs) noexcept { \
		return lhs op flag_type(rhs); \
	}

	#define MAKE_BINARY_3(op, return_type) \
	inline return_type \
	operator op(open_flag lhs, flag_type rhs) noexcept { \
		return flag_type(lhs) op rhs; \
	}

	/// Bit-wise negation.
	MAKE_UNARY(~)
	/// Bit-wise \c OR.
	MAKE_BINARY_1(|, open_flag)
	/// Comparison operator.
	MAKE_BINARY_2(|, open_flag)
	/// Comparison operator.
	MAKE_BINARY_3(|, open_flag)
	/// Bit-wise \c AND.
	MAKE_BINARY_1(&, open_flag)
	/// Comparison operator.
	MAKE_BINARY_2(&, open_flag)
	/// Comparison operator.
	MAKE_BINARY_3(&, open_flag)
	/// Bit-wise \c XOR.
	MAKE_BINARY_1(^, open_flag)
	/// Comparison operator.
	MAKE_BINARY_2(^, open_flag)
	/// Comparison operator.
	MAKE_BINARY_3(^, open_flag)
	/// Comparison operator.
	MAKE_BINARY_1(==, bool)
	/// Comparison operator.
	MAKE_BINARY_2(==, bool)
	/// Comparison operator.
	MAKE_BINARY_3(==, bool)
	/// Comparison operator.
	MAKE_BINARY_1(!=, bool)
	/// Comparison operator.
	MAKE_BINARY_2(!=, bool)
	/// Comparison operator.
	MAKE_BINARY_3(!=, bool)

	#undef MAKE_UNARY
	#undef MAKE_BINARY_1
	#undef MAKE_BINARY_2
	#undef MAKE_BINARY_3

}

#endif // vim:filetype=cpp
