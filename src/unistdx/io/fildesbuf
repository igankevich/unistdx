#ifndef UNISTDX_IO_FILDESBUF
#define UNISTDX_IO_FILDESBUF

#include <cassert>
#include <vector>

#include <unistdx/base/packetbuf>
#include <unistdx/base/streambuf_traits>
#include <unistdx/io/fildes>
#include <unistdx/util/system>

#if !defined(NDEBUG) && defined(UNISTDX_DEBUG_FILDESBUF)
#include <string.h>
#include <unistdx/base/log_message>
#endif

namespace sys {

	template<class Ch, class Tr=std::char_traits<Ch>, class Fd=sys::fildes>
	class basic_fildesbuf: public virtual basic_packetbuf<Ch,Tr> {

	private:
		typedef basic_packetbuf<Ch,Tr> base_type;
		typedef streambuf_traits<Fd> streambuf_traits_type;
		typedef std::ios_base::openmode openmode;
		typedef std::ios_base::seekdir seekdir;
		typedef std::vector<Ch> buffer_type;
		typedef typename buffer_type::size_type size_type;

	protected:
		using base_type::gptr;
		using base_type::eback;
		using base_type::egptr;
		using base_type::pptr;
		using base_type::pbase;
		using base_type::epptr;
		using base_type::setg;
		using base_type::setp;
		using base_type::gbump;
		using base_type::pbump;
		using typename base_type::int_type;
		using typename base_type::traits_type;
		using typename base_type::char_type;
		using typename base_type::pos_type;
		using typename base_type::off_type;

	public:
		typedef Fd fd_type;

		inline
		basic_fildesbuf():
		basic_fildesbuf(std::move(fd_type()), page_size())
		{}

		inline explicit
		basic_fildesbuf(fd_type&& fd):
		basic_fildesbuf(std::move(fd), page_size())
		{}

		inline
		basic_fildesbuf(fd_type&& fd, size_type bufsize):
		basic_fildesbuf(std::move(fd), bufsize, bufsize)
		{}

		inline
		basic_fildesbuf(fd_type&& fd, size_type gbufsize, size_type pbufsize):
		_fd(std::move(fd)), _gbuf(gbufsize), _pbuf(pbufsize) {
			char_type* g = _gbuf.data();
			setg(g, g, g);
			char_type* p = _pbuf.data();
			setp(p, p + _pbuf.size());
		}

		basic_fildesbuf(basic_fildesbuf&&) = delete;

		basic_fildesbuf(const basic_fildesbuf&) = delete;

		basic_fildesbuf&
		operator=(const basic_fildesbuf&) = delete;

		basic_fildesbuf&
		operator=(basic_fildesbuf&&) = delete;

		int_type
		underflow() override {
			assert(gptr() == egptr());
			setg(eback(), eback(), eback());
			return do_fill() == 0
			       ? traits_type::eof()
				   : traits_type::to_int_type(*gptr());
		}

		int_type
		overflow(int_type c) override {
			assert(pptr() == epptr());
			if (c != traits_type::eof()) {
				pgrow();
				if (pptr() != epptr()) {
					*pptr() = c;
					pbump(1);
				}
			} else {
				do_flush();
			}
			return c;
		}

		std::streamsize
		xsgetn(char_type* s, std::streamsize n) override {
			while (this->egptr() - this->gptr() < n && this->do_fill() > 0) {}
			const std::streamsize m = std::min(n, this->egptr() - this->gptr());
			traits_type::copy(s, this->gptr(), m);
			this->gbump(m);
			return m;
		}

		std::streamsize
		xsputn(const char_type* s, std::streamsize n) override {
			while (epptr() - pptr() < n) {
				this->pgrow();
			}
			traits_type::copy(pptr(), s, n);
			pbump(n);
			return n;
		}

		int
		sync() override {
			int ret = 0;
			if (has_pbuf()) {
				ret |= do_flush()==-1 ? -1 : 0;
			}
			if (has_gbuf()) {
				ret |= do_fill()==-1 ? -1 : 0;
			}
			return ret;
		}

		pos_type
		seekoff(off_type off, seekdir way, openmode which) override {
			pos_type ret(off_type(-1));
			if (way == std::ios_base::beg) {
				ret = seekpos(off, which);
			}
			if (way == std::ios_base::cur) {
				const pos_type pos = (which& std::ios_base::in)
				                     ? static_cast<pos_type>(gptr() - eback())
									 : static_cast<pos_type>(pptr() - pbase());
				ret = off == 0 ? pos : seekpos(pos + off, which);
			}
			if (way == std::ios_base::end) {
				const pos_type pos = (which& std::ios_base::in)
				                     ? static_cast<pos_type>(egptr() - eback())
									 : static_cast<pos_type>(epptr() - pbase());
				ret = seekpos(pos + off, which);
			}
			return ret;
		}

		pos_type
		seekpos(pos_type pos, openmode mode) override {
			pos_type ret(off_type(-1));
			if (mode & std::ios_base::in) {
				const std::streamsize size = egptr() - eback();
				if (pos >= 0 && pos <= size) {
					setg(eback(), eback()+pos, egptr());
					ret = pos;
				}
			}
			if (mode & std::ios_base::out) {
				if (pos >= 0 && pos <= psize()) {
					setp(pbase(), epptr());
					pbump(pos);
					ret = pos;
				}
			}
			return ret;
		}

		std::streamsize
		showmanyc() override {
			return streambuf_traits_type::in_avail(this->_fd);
		}

		inline void
		setfd(fd_type&& rhs) {
			this->_fd = std::move(rhs);
		}

		inline const fd_type&
		fd() const {
			return this->_fd;
		}

		inline fd_type&
		fd() {
			return this->_fd;
		}

		inline void
		close() {
			this->_fd.close();
		}

	private:

		inline std::streamsize
		do_fill() {
			if (this->gptr() != this->eback()) {
				const std::streamsize n = this->egptr() - this->gptr();
				char_type* g = this->eback();
				traits_type::move(g, this->gptr(), n);
				this->setg(g, g, g + n);
			}
			// TODO 2016-03-09 this is not optimal solution,
			// but i don't know a better alternative
			const std::streamsize old_egptr_offset = egptr() - eback();
			if (egptr() == glast()) {
				ggrow();
			}
			char_type* first = egptr();
			char_type* last = glast();
			std::streamsize n = 0;
			while ((n = streambuf_traits_type::read(_fd, first, last-first)) >
			       0) {
				first += n;
				setg(eback(), gptr(), first);
				if (first == last) {
					ggrow();
					first = egptr();
					last = glast();
				}
			}
			std::streamsize ret = first - (eback() + old_egptr_offset);
			#if !defined(NDEBUG) && defined(UNISTDX_DEBUG_FILDESBUF)
			sys::log_message("fdbuf", "fill _, state=_", ret, strerror(errno));
			#endif
			return ret;
		}

		inline std::streamsize
		do_flush() {
			const std::streamsize m = pptr() - pbase();
			if (m == 0) return 0;
			const std::streamsize n = streambuf_traits_type::write(
				this->_fd,
				pbase(),
				m
			                          );
			const bool success = n==m;
			if (success) {
				setp(pfirst(), plast());
			} else if (n > 0) {
				setp(pbase()+n, epptr());
				pbump(m-n);
			}
			#if !defined(NDEBUG) && defined(UNISTDX_DEBUG_FILDESBUF)
			sys::log_message("fdbuf", "flush _, state=_", n, strerror(errno));
			#endif
			return n==-1 ? 0 : n;
		}

	protected:

		inline char_type*
		gfirst() noexcept {
			return this->_gbuf.data();
		}

		inline char_type*
		glast() noexcept {
			return this->_gbuf.data() + this->_gbuf.size();
		}

		inline void
		rebase() noexcept {
			char_type* base = this->_gbuf.data();
			setg(
				base,
				base + (gptr()-eback()),
				base + (egptr()-eback())
			);
		}

		inline bool
		has_gbuf() const noexcept {
			return !this->_gbuf.empty();
		}

		inline void
		ggrow() {
			this->_gbuf.resize(_gbuf.size() * 2);
			rebase();
		}

		inline char_type*
		pfirst() noexcept {
			return this->_pbuf.data();
		}

		inline char_type*
		plast() noexcept {
			return this->_pbuf.data() + this->_pbuf.size();
		}

		inline bool
		has_pbuf() const noexcept {
			return !this->_pbuf.empty();
		}

		inline void
		pgrow(std::streamsize new_size) {
			#if !defined(NDEBUG) && defined(UNISTDX_DEBUG_FILDESBUF)
			sys::log_message("fdbuf", "pgrow size=_", new_size);
			#endif
			const off_type pptr_offset = pptr() - pbase();
			const off_type pbase_offset = pbase() - pfirst();
			this->_pbuf.resize(new_size);
			setp(pfirst() + pbase_offset, plast());
			pbump(pptr_offset);
		}

		inline void
		pgrow() {
			this->pgrow(this->_pbuf.size() * 2);
		}

		inline std::streamsize
		psize() const {
			return this->_pbuf.size();
		}

		inline std::streamsize
		gsize() const {
			return this->_gbuf.size();
		}

		fd_type _fd;
		buffer_type _gbuf;
		buffer_type _pbuf;
	};

	typedef basic_fildesbuf<char> fildesbuf;

}

#endif // vim:filetype=cpp
