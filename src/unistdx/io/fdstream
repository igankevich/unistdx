#ifndef UNISTDX_IO_FDSTREAM
#define UNISTDX_IO_FDSTREAM

#include <istream>

#include <unistdx/io/fildesbuf>

namespace sys {

	/**
	\brief Input stream that reads from file descriptor.
	\date 2018-05-22
	\author Ivan Gankevich
	\ingroup stream io
	\tparam Fd File descriptor type. Can be a wrapper class or \c int.
	\details
	\arg Any type for which \link streambuf_traits\endlink are defined, may
	be used instead of file descriptor.
	\arg Input operations are non-blocking by default.
	*/
	template<class Ch, class Tr=std::char_traits<Ch>, class Fd=sys::fildes>
	class basic_ifdstream: public std::basic_istream<Ch,Tr> {

	private:
		typedef std::basic_istream<Ch,Tr> base_type;
		typedef basic_fildesbuf<Ch,Tr,Fd> fildesbuf_type;

	public:
		using typename base_type::char_type;
		using typename base_type::traits_type;
		using typename base_type::int_type;
		using typename base_type::pos_type;
		using typename base_type::off_type;

	public:
		/// File descriptor type.
		typedef Fd fd_type;

	private:
		fildesbuf_type _fildesbuf;

	public:

		/// Construct the stream with file descriptor \p fd.
		inline explicit
		basic_ifdstream(Fd&& fd):
		base_type(nullptr),
		_fildesbuf(std::move(fd), page_size(), 0) {
			this->init(&this->_fildesbuf);
		}

		/// Open the stream with file descriptor \p rhs.
		inline void
		open(fd_type&& rhs) {
			this->close();
			this->_fildesbuf.setfd(std::move(rhs));
		}

		/// Close the stream.
		inline void
		close() {
			this->_fildesbuf.close();
		}

		/// Get file descriptor.
		inline const fd_type&
		fd() const {
			return this->_fildesbuf.fd();
		}

		/// Get file descriptor.
		inline fd_type&
		fd() {
			return this->_fildesbuf.fd();
		}

		/// Get stream buffer.
		inline const fildesbuf_type&
		fdbuf() const noexcept {
			return this->_fildesbuf;
		}

		/// Get stream buffer.
		inline fildesbuf_type&
		fdbuf() noexcept {
			return this->_fildesbuf;
		}

	};

	/**
	\brief Output stream that writes to file descriptor.
	\date 2018-05-22
	\author Ivan Gankevich
	\ingroup stream io
	\details
	\arg Any type for which \link streambuf_traits\endlink are defined, may
	be used instead of file descriptor.
	\arg Output operations are non-blocking by default.
	\arg The stream does not flush buffer contents when closed.
	*/
	template<class Ch, class Tr=std::char_traits<Ch>, class Fd=sys::fildes>
	class basic_ofdstream: public std::basic_ostream<Ch,Tr> {

	private:
		typedef std::basic_ostream<Ch,Tr> base_type;
		typedef basic_fildesbuf<Ch,Tr,Fd> fildesbuf_type;

	public:
		using typename base_type::char_type;
		using typename base_type::traits_type;
		using typename base_type::int_type;
		using typename base_type::pos_type;
		using typename base_type::off_type;

	public:
		/// File descriptor type. Can be a wrapper class or \c int.
		typedef typename fildesbuf_type::fd_type fd_type;

	private:
		fildesbuf_type _fildesbuf;

	public:

		inline
		basic_ofdstream():
		base_type(nullptr),
		_fildesbuf() {
			this->init(&_fildesbuf);
		}

		/// Construct the stream with file descriptor \p fd.
		inline explicit
		basic_ofdstream(Fd&& fd):
		base_type(nullptr),
		_fildesbuf(std::move(fd), 0, page_size()) {
			this->init(&_fildesbuf);
		}

		/// Open the stream with file descriptor \p rhs.
		inline void
		open(fd_type&& rhs) {
			this->close();
			this->_fildesbuf.setfd(std::move(rhs));
		}

		/// Close the stream.
		inline void
		close() {
			this->_fildesbuf.close();
		}

		/// Get file descriptor.
		inline const fd_type&
		fd() const {
			return this->_fildesbuf.fd();
		}

		/// Get file descriptor.
		inline fd_type&
		fd() {
			return this->_fildesbuf.fd();
		}

		/// Get stream buffer.
		inline const fildesbuf_type&
		fdbuf() const noexcept {
			return this->_fildesbuf;
		}

		/// Get stream buffer.
		inline fildesbuf_type&
		fdbuf() noexcept {
			return this->_fildesbuf;
		}

	};

	/**
	\brief Input/output stream that reads/writes to/from file descriptor.
	\date 2018-05-22
	\author Ivan Gankevich
	\ingroup stream io
	\details
	\arg Any type for which \link streambuf_traits\endlink are defined, may
	be used instead of file descriptor.
	\arg Input and output operations are non-blocking by default.
	\arg The stream does not flush buffer contents when closed.
	*/
	template<class Ch, class Tr=std::char_traits<Ch>, class Fd=sys::fildes>
	class basic_fdstream: public std::basic_iostream<Ch,Tr> {

	private:
		typedef std::basic_iostream<Ch,Tr> base_type;
		typedef basic_fildesbuf<Ch,Tr,Fd> fildesbuf_type;

	public:
		using typename base_type::char_type;
		using typename base_type::traits_type;
		using typename base_type::int_type;
		using typename base_type::pos_type;
		using typename base_type::off_type;

	public:
		/// File descriptor type. Can be a wrapper class or \c int.
		typedef typename fildesbuf_type::fd_type fd_type;

	private:
		fildesbuf_type _fildesbuf;

	public:

		/// Construct the stream with file descriptor \p fd.
		inline explicit
		basic_fdstream(Fd&& fd):
		base_type(nullptr),
		_fildesbuf(std::move(fd), page_size()) {
			this->init(&_fildesbuf);
		}

		/// Open the stream with file descriptor \p rhs.
		inline void
		open(fd_type&& rhs) {
			this->close();
			this->_fildesbuf.setfd(std::move(rhs));
		}

		/// Close the stream.
		inline void
		close() {
			this->_fildesbuf.close();
		}

		/// Get file descriptor.
		inline const fd_type&
		fd() const {
			return this->_fildesbuf.fd();
		}

		/// Get file descriptor.
		inline fd_type&
		fd() {
			return this->_fildesbuf.fd();
		}

		/// Get stream buffer.
		inline const fildesbuf_type&
		fdbuf() const noexcept {
			return this->_fildesbuf;
		}

		/// Get stream buffer.
		inline fildesbuf_type&
		fdbuf() noexcept {
			return this->_fildesbuf;
		}

	};

	/// \brief Character based input file descriptor stream.
	/// \ingroup io
	typedef basic_ifdstream<char> ifdstream;

	/// \brief Character based output file descriptor stream.
	/// \ingroup io
	typedef basic_ofdstream<char> ofdstream;

	/// \brief Character based input/output file descriptor stream.
	/// \ingroup io
	typedef basic_fdstream<char> fdstream;

}

#endif // vim:filetype=cpp
