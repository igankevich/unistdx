#ifndef UNISTDX_IPC_PROCESS
#define UNISTDX_IPC_PROCESS

#include <memory>

#include <unistdx/config>

#include <unistd.h>
#if defined(UNISTDX_HAVE_SCHED_H)
#include <sched.h>
#endif
#if defined(UNISTDX_HAVE_PRCTL)
#include <sys/prctl.h>
#endif

#include <unistdx/base/check>
#include <unistdx/base/flag>
#include <unistdx/bits/process>
#include <unistdx/bits/safe_calls>
#include <unistdx/io/fildes>
#include <unistdx/ipc/process_status>
#include <unistdx/ipc/signal>

namespace sys {

    typedef ::pid_t pid_type;

    /**
    \brief
    Send signal \p s to process \p p.
    \date 2018-05-21
    \author Ivan Gankevich
    \throw bad_call
    \see \man{kill,2}
    */
    inline void
    send(signal s, pid_type p) {
        UNISTDX_CHECK(::kill(p, signal_type(s)));
    }

    fildes get_namespace(const char* proc_suffix, pid_type p);

    enum class unshare_flag: int {
        #if defined(UNISTDX_HAVE_CLONE_FILES)
        file_descriptors = CLONE_FILES,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_FS)
        file_system = CLONE_FS,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWCGROUP)
        control_groups = CLONE_NEWCGROUP,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWIPC)
        ipc = CLONE_NEWIPC,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWNET)
        network = CLONE_NEWNET,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWNS)
        mount_points = CLONE_NEWNS,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWPID)
        processes = CLONE_NEWPID,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWUSER)
        users = CLONE_NEWUSER,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWUTS)
        hostname = CLONE_NEWUTS,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_SYSVSEM)
        ipc_sysv = CLONE_SYSVSEM,
        #endif
    };

    template <>
    struct is_flag<unshare_flag>: public std::true_type {};

    enum class namespace_type {
        any = 0,
        #if defined(UNISTDX_HAVE_CLONE_NEWCGROUP)
        control_groups = CLONE_NEWCGROUP,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWIPC)
        ipc = CLONE_NEWIPC,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWNET)
        network = CLONE_NEWNET,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWNS)
        mount_points = CLONE_NEWNS,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWPID)
        processes = CLONE_NEWPID,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWUSER)
        users = CLONE_NEWUSER,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWUTS)
        hostname = CLONE_NEWUTS,
        #endif
    };

    namespace this_process {

        /**
        \brief Get calling process ID.
        \see \man{getpid,2}
        */
        inline pid_type
        id() noexcept { return ::getpid(); }

        /**
        \brief Get calling process' parent ID.
        \see \man{getppid,2}
        */
        inline pid_type
        parent_id() noexcept { return ::getppid(); }

        /**
        \brief Fork child process preventing race conditions by
        locking global fork mutex (if needed).
        \throws bad_call
        \see \man{fork,2}
        \details
        The mutex is not locked on systems supporting close-on-exec and
        non-blocking file descriptor flags.
        */
        inline pid_type
        fork() {
            #if defined(UNISTDX_FORK_MUTEX)
            bits::global_lock_type lock(bits::fork_mutex);
            #endif
            pid_type ret;
            UNISTDX_CHECK(ret = ::fork());
            return ret;
        }

        /**
        \brief
        Send signal \p s to the current process.
        \date 2018-05-21
        \author Ivan Gankevich
        \throws bad_call
        \see \man{kill,2}
        */
        inline void
        send(signal s) {
            UNISTDX_CHECK(::kill(::sys::this_process::id(), signal_type(s)));
        }

        /**
        \brief Set current process' working directory.
        \date 2018-05-21
        \author Ivan Gankevich
        \throws bad_call
        \see \man{chdir,2}
        */
        inline void
        workdir(const char* wd) {
            UNISTDX_CHECK(::chdir(wd));
        }

        /**
        \brief Get process group ID of the calling process.
        \see \man{getpgrp,2}
        */
        inline pid_type group_id() { return ::getpgrp(); }

        /**
        \brief Set calling process group ID.
        \throws bad_call
        \see \man{setpgid,2}
        */
        inline void group_id(pid_type rhs) { UNISTDX_CHECK(::setpgid(id(), rhs)); }

        #if defined(UNISTDX_HAVE_PRCTL)
        /**
        \brief Set calling process name. Useful for debugging multi-threaded programmes.
        \throws bad_call
        \see \man{prctl,2}
        */
        inline void name(const char* name) { UNISTDX_CHECK(::prctl(PR_SET_NAME, name)); }

        /**
        \brief Get calling process name.
        \throws bad_call
        \see \man{prctl,2}
        */
        inline std::string
        name() {
            std::string nm(16, '\0');
            UNISTDX_CHECK(::prctl(PR_GET_NAME, nm.data()));
            return nm;
        }
        #endif

        #if defined(UNISTDX_HAVE_UNSHARE)
        inline void unshare(unshare_flag flags) {
            UNISTDX_CHECK(::unshare(static_cast<int>(flags)));
        }
        #endif

        #if defined(UNISTDX_HAVE_SETNS)
        inline void enter(fd_type fd, namespace_type ns=namespace_type::any) {
            UNISTDX_CHECK(::setns(fd, static_cast<int>(ns)));
        }
        #endif

        inline fildes get_namespace(const char* proc_suffix) {
            return ::sys::get_namespace(proc_suffix, id());
        }

        inline void hostname(const std::string& name) {
            UNISTDX_CHECK(::sethostname(name.data(), name.size()));
        }

        std::string hostname();

    }

    /**
    \brief
    Flags used by \man{waitid,2} system call.
    \date 2018-05-21
    \author Ivan Gankevich
    \ingroup ipc
    */
    enum class wait_flags: int {
        /// Process exited by calling \man{exit,2}.
        exited = WEXITED,
        /// Process execution was stopped by a signal.
        stopped = WSTOPPED,
        /**
        Process execution was resumed with \link signal::resume\endlink signal.
        */
        resumed = WCONTINUED,
        /// Return immediately, do not wait for child process to exit.
        non_blocking = WNOHANG
    };

    template <>
    struct is_flag<wait_flags>: public std::true_type {};

    /**
    \brief
    Flags used by \man{clone,2} system call.
    \date 2018-05-21
    \author Ivan Gankevich
    */
    enum class process_flag: int {
        fork = 0,
        signal_parent = SIGCHLD,
        #if defined(UNISTDX_HAVE_CLONE)
        wait_for_exec = CLONE_VFORK,
        new_process_namespace = CLONE_NEWPID,
        #endif
        share_memory = CLONE_VM,
        share_signal_handlesr = CLONE_SIGHAND,
        share_ipc_sysv = CLONE_SYSVSEM,
        #if defined(UNISTDX_HAVE_CLONE_FILES)
        share_file_descriptors = CLONE_FILES,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_FS)
        share_file_system = CLONE_FS,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWCGROUP)
        unshare_control_groups = CLONE_NEWCGROUP,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWIPC)
        unshare_ipc = CLONE_NEWIPC,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWNET)
        unshare_network = CLONE_NEWNET,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWNS)
        unshare_mount_points = CLONE_NEWNS,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWPID)
        unshare_processes = CLONE_NEWPID,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWUSER)
        unshare_users = CLONE_NEWUSER,
        #endif
        #if defined(UNISTDX_HAVE_CLONE_NEWUTS)
        unshare_hostname = CLONE_NEWUTS,
        #endif
    };

    template <>
    struct is_flag<process_flag>: public std::true_type {};

    /**
    \brief
    System process with \link std::thread\endlink interface.
    \date 2018-05-21
    \author Ivan Gankevich
    \ingroup ipc
    */
    class process {

    public:
        using stack_ptr = std::unique_ptr<char[]>;

    private:
        pid_type _pid = 0;
        stack_ptr _stack;

    public:

        /**
        \brief Construct new process by forking a child with \p f as main function.
        \throws bad_call
        \see \man{clone,2}
        \see \man{fork,2}
        */
        template<class F>
        inline explicit
        process(F f, process_flag flags=process_flag::fork, size_t stack_size=4096*4) {
            typedef bits::call_traits<decltype(f())> traits_type;
            if (flags == process_flag::fork) {
                this->_pid = this_process::fork();
                if (this->_pid == 0) {
                    std::exit(traits_type::call(f));
                }
            #if defined(UNISTDX_HAVE_CLONE)
            } else {
                this->_stack.reset(new char[stack_size]);
                this->_pid = ::clone(
                    &traits_type::template child_main<F>,
                    this->_stack.get() + stack_size,
                    static_cast<int>(flags),
                    &f
                );
                // do not delete the stack for threads
                if (!(flags & process_flag::share_memory)) { this->_stack.reset(); }
                UNISTDX_CHECK(this->_pid);
            #endif
            }
        }

        /// Construct process by its ID.
        inline explicit process(pid_type rhs): _pid(rhs) {}

        inline process() = default;
        process(const process&) = delete;

        /// Move-constructor.
        inline process(process&& rhs): _pid(rhs._pid), _stack(std::move(rhs._stack))
        { rhs._pid = 0; }

        /// Terminates the process, if any.
        inline ~process() { if (this->_pid > 0) { this->do_kill(sys::signal::terminate); } }

        /// Move-assignment.
        inline process& operator=(process&& rhs) { this->swap(rhs); return *this; }

        /**
        Gracefully terminate the process by sending \link signal::terminate\endlink
        signal.
        \see \man{kill,2}
        */
        inline void terminate() { this->send(sys::signal::terminate); }

        /**
        \brief
        Forcibly terminate the process by sending \link signal::kill\endlink
        signal.
        \throws bad_call
        \see \man{kill,2}
        */
        inline void kill() { this->send(sys::signal::kill); }

        /**
        \brief
        Interrupt the process by sending \link signal::keyboard_interrupt\endlink
        signal.
        \throws bad_call
        \see \man{kill,2}
        */
        inline void interrupt() { this->send(sys::signal::keyboard_interrupt); }

        /**
        \brief
        Interrupt the process by sending \link signal::hang_up\endlink signal.
        \throws bad_call
        \see \man{kill,2}
        */
        inline void hang_up() { this->send(sys::signal::hang_up); }

        /**
        \brief
        Interrupt the process by sending \link signal::stop\endlink signal.
        \throws bad_call
        \see \man{kill,2}
        */
        inline void stop() { this->send(sys::signal::stop); }

        /**
        \brief
        Interrupt the process by sending \link signal::resume\endlink signal.
        \throws bad_call
        \see \man{kill,2}
        */
        inline void resume() { this->send(sys::signal::resume); }

        /**
        \brief Send signal \p s to the process.
        \throws bad_call
        */
        inline void send(sys::signal s) { UNISTDX_CHECK(this->do_kill(s)); }

        /**
        \brief Wait until process changes its state or terminates.
        \throws bad_call if system error occurs, except
        \c std::errc::interrupted
        \see std::errc
        \see \man{waitpid,2}
        */
        inline sys::process_status
        wait(wait_flags flags = wait_flags::exited) {
            sys::siginfo_type info;
            UNISTDX_CHECK(::waitid(P_PID, this->_pid, &info, int(flags)));
            sys::process_status status(info);
            if (status.exited()) { this->_pid = 0; this->_stack.reset(); }
            return status;
        }

        /// Check if process is alive by sending nought signal to it.
        inline explicit
        operator bool() const { return this->_pid > 0 && do_kill(sys::signal{}) != -1; }

        /// Check if process is alive by sending nought signal to it.
        inline bool operator !() const { return !this->operator bool(); }

        /// Swap with \p rhs.
        inline void swap(process& rhs) {
            std::swap(this->_pid, rhs._pid);
            std::swap(this->_stack, rhs._stack);
        }

        /// Get process ID.
        inline pid_type id() const { return this->_pid; }

        /**
        \brief Get process group ID.
        \see \man{getpgid,2}
        */
        inline pid_type group_id() const { return ::getpgid(this->_pid); }

        /**
        \brief Set process group ID.
        \throws bad_call
        \see \man{setpgid,2}
        */
        inline void
        group_id(pid_type rhs) const {
            UNISTDX_CHECK(::setpgid(this->_pid, rhs));
        }

        /// Always returns true to be compatible with \link std::thread\endlink.
        inline bool joinable() const { return true; }

        /// \copydoc wait
        inline void join() { this->wait(); }

        inline fildes get_namespace(const char* proc_suffix) {
            return ::sys::get_namespace(proc_suffix, id());
        }

        void init_user_namespace();

    private:

        inline int do_kill(sys::signal sig) const noexcept {
            return ::kill(this->_pid, signal_type(sig));
        }

    };

    /// Overload of \link std::swap\endlink for \link process\endlink.
    inline void
    swap(process& lhs, process& rhs) {
        lhs.swap(rhs);
    }

    /// Output process ID and process group ID.
    std::ostream&
    operator<<(std::ostream& out, const process& rhs);

}

#endif // vim:filetype=cpp
