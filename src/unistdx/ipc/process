#ifndef UNISTDX_IPC_PROCESS
#define UNISTDX_IPC_PROCESS

#include <unistdx/config>

#include <unistd.h>
#if defined(UNISTDX_HAVE_CLONE)
#include <sched.h>
#endif
#if defined(UNISTDX_HAVE_PRCTL)
#include <sys/prctl.h>
#endif

#include <unistdx/base/check>
#include <unistdx/bits/safe_calls>
#include <unistdx/ipc/proc_info>
#include <unistdx/ipc/proc_status>
#include <unistdx/ipc/signal>

namespace sys {

	typedef ::pid_t pid_type;

	/**
	\brief
	Send signal \p s to process \p p.
	\date 2018-05-21
	\author Ivan Gankevich
	\ingroup comm
	*/
	inline void
	send(signal s, pid_type p) {
		UNISTDX_CHECK(::kill(p, signal_type(s)));
	}

	namespace this_process {

		/// Get calling process ID.
		inline pid_type
		id() noexcept { return ::getpid(); }

		/// Get calling process' parent ID.
		inline pid_type
		parent_id() noexcept { return ::getppid(); }

		/**
		\brief Fork child process preventing race conditions by
		locking global fork mutex (if needed).
		\details
		The mutex is not locked on systems supporting close-on-exec and
		non-blocking file descriptor flags.
		*/
		inline pid_type
		fork() {
			#if defined(UNISTDX_FORK_MUTEX)
			bits::global_lock_type lock(bits::fork_mutex);
			#endif
			pid_type ret;
			UNISTDX_CHECK(ret = ::fork());
			return ret;
		}

		/**
		\brief
		Send signal \p s to the current process.
		\date 2018-05-21
		\author Ivan Gankevich
		\ingroup comm
		*/
		inline void
		send(signal s) {
			UNISTDX_CHECK(::kill(::sys::this_process::id(), signal_type(s)));
		}

		/**
		\brief Set current process' working directory.
		\date 2018-05-21
		\author Ivan Gankevich
		*/
		inline void
		workdir(const char* wd) {
			UNISTDX_CHECK(::chdir(wd));
		}

		/// Set calling process group ID.
		inline void
		set_group_id(pid_type rhs) {
			UNISTDX_CHECK(::setpgid(::sys::this_process::id(), rhs));
		}

		#if defined(UNISTDX_HAVE_PRCTL)
		/// Set calling process name. Useful for debugging multi-threaded programmes.
		inline void
		set_name(const char* name) {
			UNISTDX_CHECK(::prctl(PR_SET_NAME, name));
		}

		/// Get calling process name.
		inline std::string
		name() {
			std::string nm(16, '\0');
			UNISTDX_CHECK(::prctl(PR_GET_NAME, nm.data()));
			return nm;
		}
		#endif

	}

	/**
	\brief
	Flags used by \c waitid system call.
	\date 2018-05-21
	\author Ivan Gankevich
	\ingroup ipc
	*/
	enum wait_flags {
		proc_exited = WEXITED,
		proc_stopped = WSTOPPED,
		proc_continued = WCONTINUED
	};

	/**
	\brief
	Flags used by \c clone system call.
	\date 2018-05-21
	\author Ivan Gankevich
	*/
	enum class process_flag {
		fork
		#if defined(UNISTDX_HAVE_CLONE)
		, wait_for_exec
		#endif
	};

	namespace bits {
		template <class F>
		int
		child_main(void* arg) {
			F* func = reinterpret_cast<F*>(arg);
			int ret;
			try {
				ret = (*func)();
			} catch (...) {
				ret = 1;
			}
			std::exit(ret);
		}
	}


	/**
	\brief System process with \c std::thread interface.
	\date 2018-05-21
	\author Ivan Gankevich
	\ingroup ipc
	*/
	class process {

	public:

		/// Construct new process by forking a child with \p f as main function.
		template<class F>
		inline explicit
		process(F f, process_flag pf=process_flag::fork) {
			if (pf == process_flag::fork) {
				this->_pid = this_process::fork();
				if (this->_pid == 0) {
					int ret;
					try {
						ret = f();
					} catch (...) {
						ret = 1;
					}
					std::exit(ret);
				}
			#if defined(UNISTDX_HAVE_CLONE)
			} else if (pf == process_flag::wait_for_exec) {
				char stack[4096] = {0};
				UNISTDX_CHECK(this->_pid = ::clone(
					&bits::child_main<F>,
					stack + sizeof(stack),
					CLONE_VFORK | SIGCHLD,
					&f
				));
			#endif
			}
		}

		/// Construct process by its ID.
		inline explicit
		process(pid_type rhs) noexcept:
		_pid(rhs)
		{}

		inline process() = default;
		process(const process&) = delete;

		/// Move-constructor.
		inline
		process(process&& rhs) noexcept:
		_pid(rhs._pid)
		{
			rhs._pid = 0;
		}

		/// Terminates the process, if any.
		inline
		~process() {
			if (this->_pid > 0) {
				this->do_kill(sys::signal::terminate);
			}
		}

		/// Move-assignment.
		inline process&
		operator=(process&& rhs) noexcept {
			std::swap(_pid, rhs._pid);
			return *this;
		}

		/**
		Gracefully terminate the process by sending \link signal::terminate\endlink
		signal.
		*/
		inline void
		terminate() {
			this->send(sys::signal::terminate);
		}

		/**
		Forcibly terminate the process by sending \link signal::kill\endlink signal.
		*/
		inline void
		kill() {
			this->send(sys::signal::kill);
		}

		/**
		Interrupt the process by sending \link signal::keyboard_interrupt\endlink
		signal.
		*/
		inline void
		interrupt() {
			this->send(sys::signal::keyboard_interrupt);
		}

		/**
		Interrupt the process by sending \link signal::hang_up\endlink signal.
		*/
		inline void
		hang_up() {
			this->send(sys::signal::hang_up);
		}

		/// Send signal \p s to the process.
		inline void
		send(sys::signal s) {
			if (this->_pid > 0) {
		    	UNISTDX_CHECK(do_kill(s));
			}
		}

		/// Wait until process changes its state or terminates.
		inline sys::proc_status
		wait() {
			int stat = 0;
			if (this->_pid > 0) {
				UNISTDX_CHECK_IF_NOT(EINTR, ::waitpid(this->_pid, &stat, 0));
				this->_pid = 0;
			}
			return sys::proc_status(stat);
		}

		/// Check if process is alive by sending nought signal to it.
		inline explicit
		operator bool() const noexcept {
			return this->_pid > 0 && do_kill(sys::signal(0)) != -1;
		}

		/// Check if process is alive by sending nought signal to it.
		inline bool
		operator !() const noexcept {
			return !operator bool();
		}

		friend std::ostream&
		operator<<(std::ostream& out, const process& rhs);

		/// Get process ID.
		inline pid_type
		id() const noexcept {
			return this->_pid;
		}

		/// Get process group ID.
		inline pid_type
		group_id() const noexcept {
			return ::getpgid(this->_pid);
		}

		/// Set process group ID.
		inline void
		set_group_id(pid_type rhs) const {
			UNISTDX_CHECK(::setpgid(_pid, rhs));
		}

		/// Always returns true to be compatible with \c std::thread.
		inline bool
		joinable() {
			return true;
		}

		/// \copydoc wait
		inline void
		join() {
			this->wait();
		}

	private:

		inline int
		do_kill(sys::signal sig) const noexcept {
		   	return ::kill(_pid, signal_type(sig));
		}

		pid_type _pid = 0;

	};

	/// Output process ID and process group ID.
	std::ostream&
	operator<<(std::ostream& out, const process& rhs);

}

#endif // vim:filetype=cpp
