#ifndef UNISTDX_IPC_PROC_INFO
#define UNISTDX_IPC_PROC_INFO

#include <sys/wait.h>

#include <unistdx/ipc/basic_status>
#include <unistdx/ipc/signal>

namespace sys {

	/**
	\brief Alias for signinfo_t;
	\date 2018-05-21
	\author Ivan Gankevich
	\ingroup ipc
	*/
	typedef ::siginfo_t siginfo_type;

	/**
	\brief Alias for pid_t;
	\date 2018-05-21
	\author Ivan Gankevich
	\ingroup ipc
	*/
	typedef ::pid_t pid_type;

	/**
	\brief
	A \link basic_status\endlink object that tells how the process
	was terminated.
	\date 2018-05-21
	\author Ivan Gankevich
	\ingroup ipc wrapper
	\details Wraps \link siginfo_type\endlink.
	*/
	template<>
	struct basic_status<siginfo_type> {

	public:
		/// Enumeration of reasons for process status change.
		enum struct reason {
			exited = CLD_EXITED,
			killed = CLD_KILLED,
			core_dumped = CLD_DUMPED,
			stopped = CLD_STOPPED,
			trapped = CLD_TRAPPED,
			continued = CLD_CONTINUED
		};

	private:
		reason _reason = static_cast<reason>(0);
		code_type _code = 0;
		pid_type _pid = 0;

	public:

		/// Construct process info from signal info.
		inline explicit constexpr
		basic_status(const siginfo_type& rhs) noexcept:
		_reason(static_cast<reason>(rhs.si_code)),
		_code(rhs.si_status),
		_pid(rhs.si_pid) {}

		inline constexpr
		basic_status() noexcept = default;

		/// Copy-constructor.
		inline constexpr
		basic_status(const basic_status&) noexcept = default;

		/// Get process status code.
		inline constexpr reason
		what() const noexcept {
			return this->_reason;
		}

		/// \copydoc what
		inline constexpr reason
		status() const noexcept {
			return this->_reason;
		}

		/// Process has exited.
		inline constexpr bool
		exited() const noexcept {
			return this->_reason == reason::exited;
		}

		/// Process has beed killed.
		inline constexpr bool
		killed() const noexcept {
			return this->_reason == reason::killed;
		}

		/// Process has beed stopped.
		inline constexpr bool
		stopped() const noexcept {
			return this->_reason == reason::stopped;
		}

		/// Process has dumped the core.
		inline constexpr bool
		core_dumped() const noexcept {
			return this->_reason == reason::core_dumped;
		}

		/// Process has been trapped.
		inline constexpr bool
		trapped() const noexcept {
			return this->_reason == reason::trapped;
		}

		/// Process received a signal to continue execution after a stop.
		inline constexpr bool
		continued() const noexcept {
			return this->_reason == reason::continued;
		}

		/// Get process exit code.
		inline constexpr code_type
		exit_code() const noexcept {
			return _code;
		}

		/// Get process termination signal.
		inline constexpr signal
		term_signal() const noexcept {
			return signal(_code);
		}

		/// Get process stop signal.
		inline constexpr signal
		stop_signal() const noexcept {
			return signal(_code);
		}

		/// Get process ID.
		inline constexpr pid_type
		pid() const noexcept {
			return this->_pid;
		}

		/// Get process status string.
		inline constexpr const char*
		status_string() const noexcept {
			return ::sys::status_string<siginfo_type>(*this);
		}

	};

	/**
	\brief Alias for basic_status<siginfo_type>.
	\date 2018-05-21
	\author Ivan Gankevich
	\ingroup ipc
	*/
	typedef basic_status<siginfo_type> proc_info;

	/**
	\brief Output PID, exit status, exit code/termination signal.
	\date 2018-05-21
	\author Ivan Gankevich
	*/
	std::ostream&
	operator<<(std::ostream& out, const proc_info& rhs);

}

#endif // vim:filetype=cpp
