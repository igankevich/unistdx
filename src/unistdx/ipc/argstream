#ifndef UNISTDX_IPC_ARGSTREAM
#define UNISTDX_IPC_ARGSTREAM

#include <cassert>
#include <ostream>
#include <streambuf>
#include <vector>

namespace sys {

	/**
	\defgroup stream I/O streams
	\brief Input/output streams.
	*/

	/**
	\brief Stream buffer for command line arguments.
	\date 2018-05-21
	\author Ivan Gankevich
	\ingroup ipc streambuf
	*/
	template<class Ch, class Tr=std::char_traits<Ch>>
	class basic_argbuf: public std::basic_streambuf<Ch,Tr> {

	private:
		typedef std::basic_streambuf<Ch,Tr> base_type;

	public:
		using typename base_type::int_type;
		using typename base_type::traits_type;
		using typename base_type::char_type;
		using base_type::pptr;
		using base_type::pbase;
		using base_type::epptr;
		using base_type::pbump;

	public:
		/// Single argument type.
		typedef std::vector<char_type> arg_type;

		inline
		basic_argbuf() {
			this->_args.reserve(4096);
			this->_args.emplace_back();
			this->_rawargs.push_back(nullptr);
		}

		/// Move-constructor.
		inline
		basic_argbuf(basic_argbuf&& rhs):
		_args(std::move(rhs._args)),
		_rawargs(std::move(rhs._rawargs))
		{
			for	(size_t i=0; i<_args.size(); ++i) {
				this->_rawargs[i] = this->_args[i].data();
			}
		}

		basic_argbuf(const basic_argbuf&) = delete;

		~basic_argbuf() = default;

		/// See \c std::streambuf::overflow.
		inline int_type
		overflow(int_type c) override {
			assert(pptr() == epptr());
			if (not traits_type::eq_int_type(c, traits_type::eof())) {
				arg_type& arg = this->_args.back();
				arg.push_back(traits_type::to_char_type(c));
				if (traits_type::eq_int_type(c, int_type(0))) {
					append_arg();
				}
			}
			return c;
		}

		/// See \c std::streambuf::xsputn.
		inline std::streamsize
		xsputn(const char_type* s, std::streamsize n) override {
			if (n == 1) {
				overflow(traits_type::to_int_type(*s));
			} else {
				arg_type& arg = this->_args.back();
				const auto old_size = arg.size();
				arg.resize(old_size + n);
				traits_type::copy(arg.data() + old_size, s, n);
			}
			return n;
		}

		/// Get argument array suitable to pass to \c execve system call.
		inline char**
		argv() noexcept {
			return this->_rawargs.data();
		}

		/// Get argument array suitable to pass to \c execve system call.
		inline char* const*
		argv() const noexcept {
			return this->_rawargs.data();
		}

		/// Get the number of arguments.
		inline int
		argc() const noexcept {
			return this->_rawargs.size()-1;
		}

		/// Output all arguments, one argument per line.
		inline friend std::ostream&
		operator<<(std::ostream& out, const basic_argbuf& rhs) {
			for (int i=0; i<rhs.argc(); ++i) {
				out << rhs._rawargs[i] << '\n';
			}
			return out;
		}

	private:

		inline void
		append_arg() {
			this->_rawargs.back() = _args.back().data();
			this->_rawargs.push_back(nullptr);
			this->_args.emplace_back();
		}

		std::vector<arg_type> _args;
		std::vector<char_type*> _rawargs;

	};

	/**
	\brief Output stream of command line arguments.
	\date 2018-05-21
	\author Ivan Gankevich
	\ingroup ipc stream
	\details
	\arg Use \link append\endlink method to append one argument at a time.
	\arg Insert any object to the stream to append its textual
	representation to the current command line argument.
	\arg Insert null character to delimit arguments manually.
	*/
	class argstream: public std::ostream {

	private:
		typedef char char_type;
		typedef std::char_traits<char_type> traits_type;
		typedef basic_argbuf<char_type,traits_type> argbuf_type;

	private:
		argbuf_type _argbuf;

	public:

		inline
		argstream():
		std::ostream(nullptr)
		{ this->init(&_argbuf); }

		/// Move-constructor
		inline
		argstream(argstream&& rhs):
		std::ostream(),
		_argbuf(std::move(rhs._argbuf))
		{ this->init(&_argbuf); }

		/// Get argument array suitable to pass to \c execve system call.
		inline char**
		argv() noexcept {
			return _argbuf.argv();
		}

		/// Get argument array suitable to pass to \c execve system call.
		inline char* const*
		argv() const noexcept {
			return _argbuf.argv();
		}

		/// Get the number of arguments.
		inline int
		argc() const noexcept {
			return _argbuf.argc();
		}

		/// Insert \p rhs to the stream and delimit the current argument.
		template<class T>
		inline void
		append(const T& rhs) {
			*this << rhs << '\0';
		}

		/// Insert all function arguments as command line arguments.
		template<class T, class ... Args>
		inline void
		append(const T& first, const Args& ... args) {
			append(first);
			append(args...);
		}

	};

}

#endif // vim:filetype=cpp
