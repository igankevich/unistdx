#ifndef UNISTDX_IPC_PROCESS_GROUP
#define UNISTDX_IPC_PROCESS_GROUP

#include <algorithm>
#include <vector>

#include <unistdx/base/unlock_guard>
#include <unistdx/ipc/process>

namespace sys {

	namespace this_process {

		/**
		\brief Get process group ID of the calling process.
		\see \man{getpgrp,2}
		*/
		inline pid_type
		process_group_id() noexcept { return ::getpgrp(); }

		/**
		\brief Set process group ID of the calling process.
		\throws bad_call
		\see \man{setpgid,2}
		*/
		inline void
		set_process_group_id(pid_type rhs) {
			UNISTDX_CHECK(::setpgid(this_process::id(), rhs));
		}

	}

	/**
	\brief A group of processes.
	\date 2018-05-21
	\author Ivan Gankevich
	\ingroup ipc container
	*/
	class process_group {

	public:
		/// Container iterator.
		typedef std::vector<process>::iterator iterator;
		/// Container constant iterator.
		typedef std::vector<process>::const_iterator const_iterator;

	private:
		std::vector<process> _procs;
		pid_type _gid = 0;

	public:

		process_group() = default;

		~process_group() = default;

		/// Move-constructor.
		process_group(process_group&& rhs) = default;

		process_group(const process_group&) = delete;

		process_group&
		operator=(const process_group&) = delete;

		/// Move-assignment.
		inline process_group&
		operator=(process_group&& rhs) {
			this->swap(rhs);
			return *this;
		}

		/// Add new process to a group using \p childmain as the main function.
		template<class F>
		const process&
		emplace(F&& childmain, process_flag pf=process_flag::fork) {
			const bool has_gid = !this->_procs.empty();
			this->_procs.emplace_back([this,&childmain,has_gid] () {
				this_process::set_group_id(
					has_gid ? this->_gid : this_process::id()
				);
				return childmain();
			}, pf);
			process& proc = this->_procs.back();
			if (!has_gid) {
				this->_gid = proc.id();
			}
			return proc;
		}

		/// Wait until all processes finish their execution.
		int
		wait();

		/**
		\brief Wait until all processes finish their execution
		unlocking \p lock for the duration of wait.
		\throws bad_call if system error occurs, except
		\c std::errc::interrupted
		\see std::errc
		\see \man{waitid,2}
		*/
		template<class Lock, class F>
		void
		wait(Lock& lock, F callback, wait_flags flags=wait_flags::exited) {
			sys::siginfo_type info;
			sys::proc_info status;
			const_iterator result;
			while (!this->_procs.empty()) {
				{
					unlock_guard<Lock> g(lock);
					UNISTDX_CHECK_IF_NOT(
						EINTR,
						::waitid(P_PGID, this->_gid, &info, static_cast<int>(flags))
					);
				}
				status = sys::proc_info(info);
				result = std::find_if(
					this->_procs.begin(), this->_procs.end(),
					[&status] (const process& p) {
						return p.id() == status.pid();
					}
				);
				if (result != this->_procs.end()) {
					callback(*result, status);
					this->_procs.erase(result);
				}
			}
		}

		/**
		\brief Send signal \p s to all processes in the group.
		\throws bad_call
		\see \man{killpg,2}
		*/
		inline void
		send(signal s) {
			if (this->_gid > 0) {
		    	UNISTDX_CHECK(::killpg(this->_gid, signal_type(s)));
			}
		}

		/**
		\brief Terminate all processes in the group.
		\throws bad_call
		*/
		inline void
		terminate() {
			this->send(signal::terminate);
		}

		/// Get process group ID.
		inline pid_type
		id() const noexcept {
			return this->_gid;
		}

		/// Get process by index \p i.
		const process&
		operator[](size_t i) const noexcept {
			return this->_procs[i];
		}

		/// Get process by index \p i.
		inline process&
		operator[](size_t i) noexcept {
			return this->_procs[i];
		}

		/// Get the number of proccess in the group.
		inline size_t
		size() const noexcept {
			return this->_procs.size();
		}

		/// Returns iterator to the beginning of the container.
		inline iterator
		begin() noexcept {
			return this->_procs.begin();
		}

		/// Returns iterator to the end of the container.
		inline iterator
		end() noexcept {
			return this->_procs.end();
		}

		/// Returns the first process.
		inline const process&
		front() const noexcept {
			return this->_procs.front();
		}

		/// Returns the first process.
		inline process&
		front() noexcept {
			return this->_procs.front();
		}

		/// Returns the last process.
		inline const process&
		back() const noexcept {
			return this->_procs.back();
		}

		/// Returns the last process.
		inline process&
		back() noexcept {
			return this->_procs.back();
		}

		/// Check if the group is empty.
		inline bool
		empty() const noexcept {
			return this->_procs.empty();
		}

		/// Swap with \p rhs.
		inline void
		swap(process_group& rhs) {
			std::swap(this->_procs, rhs._procs);
			std::swap(this->_gid, rhs._gid);
		}

		friend std::ostream&
		operator<<(std::ostream& out, const process_group& rhs);

	};

	/// Overload of \link std::swap\endlink for \link process_group\endlink.
	inline void
	swap(process_group& lhs, process_group& rhs) {
		lhs.swap(rhs);
	}

	/// Output process group ID and all processes in the group.
	std::ostream&
	operator<<(std::ostream& out, const process_group& rhs);

}

#endif // vim:filetype=cpp
