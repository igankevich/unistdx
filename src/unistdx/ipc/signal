#ifndef UNISTDX_IPC_SIGNAL
#define UNISTDX_IPC_SIGNAL

#include <signal.h>

#include <iosfwd>

#include <unistdx/base/check>
#include <unistdx/config>

namespace sys {

	/**
	\defgroup wrapper Wrappers
	\brief Wrappers for system structures.
	*/

	/**
	\brief Alias for signal type.
	\date 2018-05-21
	\author Ivan Gankevich
	\ingroup comm
	*/
	typedef int signal_type;

	/**
	\brief Alias for \c sigaction system type.
	\date 2018-05-21
	\author Ivan Gankevich
	\ingroup comm
	*/
	typedef struct ::sigaction sigaction_type;

	/**
	\brief Signal enumeration.
	\date 2018-05-21
	\author Ivan Gankevich
	\ingroup comm
	*/
	enum struct signal: signal_type {
		// POSIX.1-1990
		/// Interrupt.
		hang_up = SIGHUP,
		/// Keyboard interrupt.
		keyboard_interrupt = SIGINT,
		quit = SIGQUIT,
		illegal_instruction = SIGILL,
		abort = SIGABRT,
		floating_point_exception = SIGFPE,
		/// Forcibly terminate.
		kill = SIGKILL,
		segmentation_fault = SIGSEGV,
		broken_pipe = SIGPIPE,
		alarm = SIGALRM,
		/// Gracefully terminate.
		terminate = SIGTERM,
		user_defined_1 = SIGUSR1,
		user_defined_2 = SIGUSR2,
		child = SIGCHLD,
		resume = SIGCONT,
		stop = SIGSTOP,
		stop_from_terminal = SIGTSTP,
		terminal_input = SIGTTIN,
		terminal_output = SIGTTOU,
		// POSIX.1-2001
		bad_memory_access = SIGBUS,
		#if defined(UNISTDX_HAVE_SIGPOLL)
		poll = SIGPOLL,
		#endif
		profile = SIGPROF,
		bad_argument = SIGSYS,
		breakpoint = SIGTRAP,
		urgent = SIGURG,
		virtual_alarm = SIGVTALRM,
		cpu_time_limit_exceeded = SIGXCPU,
		file_size_limit_exceeded = SIGXFSZ
		                           // non-standard
		#if defined(UNISTDX_HAVE_SIGSTKFLT)
		, coprocessor_stack_fault = SIGSTKFLT
		#endif
		#if defined(UNISTDX_HAVE_SIGPWR)
		, power_failure = SIGPWR
		#endif
		#if defined(UNISTDX_HAVE_SIGWINCH)
		, window_resize = SIGWINCH
		#endif
	};

	/**
	\brief Output signal name.
	\date 2018-05-21
	\author Ivan Gankevich
	\ingroup comm
	*/
	std::ostream&
	operator<<(std::ostream& out, const signal rhs);

	/**
	\brief Signal callback.
	\date 2018-05-21
	\author Ivan Gankevich
	\ingroup ipc comm wrapper
	*/
	class signal_action: public sigaction_type {
	public:

		inline
		signal_action() = default;

		/// Construct signal action from old-style signal handler.
		inline
		signal_action(void (*func)(int)) noexcept {
			this->sa_handler = func;
		}

		/// Construct signal action from new-style signal handler.
		inline
		signal_action(void (*func)(int, siginfo_t*, void*)) noexcept {
			this->sa_sigaction = func;
			this->sa_flags = SA_SIGINFO;
		}

	};

	/// Routines implicitly applied to the currect process.
	namespace this_process {

		/**
		\brief Set signal callback function.
		\date 2018-05-21
		\author Ivan Gankevich
		\ingroup comm
		*/
		inline void
		bind_signal(signal sig, const signal_action& action) {
			UNISTDX_CHECK(::sigaction(signal_type(sig), &action, 0));
		}

		/**
		\brief Ignore specified signal
		\date 2018-05-21
		\author Ivan Gankevich
		\ingroup comm
		\details
		By default any signal for which callback function
		is not set may kill the process. This routine allows to ignore
		specified signals.
		*/
		inline void
		ignore_signal(signal sig) {
			bind_signal(sig, SIG_IGN);
		}

	}

	#if !defined(__MACH__)
	/**
	\brief Signal set.
	\date 2018-05-21
	\author Ivan Gankevich
	\ingroup ipc comm wrapper
	*/
	class sigset_type: public ::sigset_t {
	public:

		/// Construct empty signal set.
		inline
		sigset_type() {
			UNISTDX_CHECK(::sigemptyset(this));
		}

		/// Construct signal set containing only signal \p s.
		inline explicit
		sigset_type(signal_type s):
		sigset_type() {
			UNISTDX_CHECK(::sigaddset(this, s));
		}

		/// Call \p func for each signal in the set.
		template<class F>
		void
		for_each(F func) {
			for (signal_type s=1; s<=31; ++s) {
				int ret;
				UNISTDX_CHECK(ret = ::sigismember(this, s));
				if (ret) {
					func(s);
				}
			}
		}

	};

	/**
	\brief Blocks/unblocks specified signals upon creation/destruction.
	\date 2018-05-21
	\author Ivan Gankevich
	\ingroup ipc comm guard
	*/
	class signal_guard {

	private:
		sigset_type _signals;

	public:

		/// Construct signal guard that blocks all signals in set \p s.
		inline explicit
		signal_guard(sigset_type s):
		_signals(s) {
			this->lock();
		}

		inline
		~signal_guard() {
			this->unlock();
		}

		/// Block all specified signals.
		inline void
		lock() {
			this->change_mask(SIG_BLOCK);
		}

		/// Unblock all specified signals.
		inline void
		unlock() {
			this->change_mask(SIG_UNBLOCK);
		}

	private:

		inline void
		change_mask(int how) {
			UNISTDX_CHECK(::sigprocmask(how, &this->_signals, 0));
		}

	};
	#endif // if !defined(__MACH__)

}

#endif // vim:filetype=cpp
