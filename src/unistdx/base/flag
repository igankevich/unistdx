#ifndef UNISTDX_BASE_FLAG
#define UNISTDX_BASE_FLAG

#include <type_traits>

namespace sys {

    template <class T>
    struct is_flag: public std::false_type {};

    /// \{

    #define UNISTDX_MAKE_OP(op) \
        template <class T> \
        inline constexpr typename std::enable_if<is_flag<T>::value,T>::type \
        operator op(T a, T b) { \
            using tp = typename std::underlying_type<T>::type; \
            return T(tp(a) op tp(b)); \
        }

    UNISTDX_MAKE_OP(|)
    UNISTDX_MAKE_OP(&)
    UNISTDX_MAKE_OP(^)

    #undef UNISTDX_MAKE_OP

    #define UNISTDX_MAKE_OP(op,op2) \
        template <class T> \
        inline constexpr typename std::enable_if<is_flag<T>::value,T>::type \
        operator op(T& a, T b) { \
            using tp = typename std::underlying_type<T>::type; \
            return a = T(tp(a) op2 tp(b)); \
        }

    UNISTDX_MAKE_OP(|=,|)
    UNISTDX_MAKE_OP(&=,&)
    UNISTDX_MAKE_OP(^=,^)

    #undef UNISTDX_MAKE_OP

    template <class T>
    inline constexpr typename std::enable_if<is_flag<T>::value,T>::type
    operator~(T a) {
        using tp = typename std::underlying_type<T>::type;
        return T(~tp(a));
    }
    /// \}

}

#endif // vim:filetype=cpp
