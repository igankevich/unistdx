#ifndef UNISTDX_BASE_CHECK
#define UNISTDX_BASE_CHECK

#include <unistdx/base/bad_call>

/**
\brief
Uncoditionally throw \link sys::bad_call\endlink
with error code and error location.
\ingroup macros
*/
#define UNISTDX_THROW_BAD_CALL() \
	throw ::sys::bad_call(__FILE__, __LINE__, __func__)

/**
\brief
Check if \p func equals -1 and throw \link sys::bad_call\endlink
with error code and error location.
\ingroup macros
*/
#define UNISTDX_CHECK(func) \
{ \
	if ((func) == -1) { \
		throw ::sys::bad_call(__FILE__, __LINE__, __func__); \
	} \
}

/**
\brief
Check if \p func equals \p ret and throw \link sys::bad_call\endlink
with error code and error location.
\ingroup macros
*/
#define UNISTDX_CHECK2(func, ret) \
{ \
	if ((func) == (ret)) { \
		throw ::sys::bad_call(__FILE__, __LINE__, __func__); \
	} \
}

/**
\brief
Check if \p func equals \p ret and throw \link sys::bad_call\endlink
with error code and error location unless \man{errno,3} equals \p good_err.
\ingroup macros
*/
#define UNISTDX_CHECK_IF_NOT(good_err, func) \
{ \
	if ((func) == -1 && errno != (good_err)) { \
		throw ::sys::bad_call(__FILE__, __LINE__, __func__); \
	} \
}

/**
\brief
Check if \p func equals -1 and throw \link sys::bad_call\endlink
with error code and error location unless \man{errno,3} equals \c EAGAIN
or \c EINPROGRESS. In that case set \p func to 0.
\ingroup macros
*/
#define UNISTDX_CHECK_IO(func) \
{ \
	if (func == -1) { \
		if (errno != EAGAIN && errno != EINPROGRESS) { \
			throw ::sys::bad_call(__FILE__, __LINE__, __func__); \
		} \
		func = 0; \
	} \
}

#endif // vim:filetype=cpp
