#ifndef UNISTDX_BASE_CHECK
#define UNISTDX_BASE_CHECK

#include <system_error>
#include <iosfwd>

/**
\brief
Uncoditionally throw \link sys::bad_call\endlink
with error code and error location.
\ingroup macros
*/
#define UNISTDX_THROW_BAD_CALL() \
	throw ::sys::bad_call(__FILE__, __LINE__, __func__)

/**
\brief
Check if \p func equals -1 and throw \link sys::bad_call\endlink
with error code and error location.
\ingroup macros
*/
#define UNISTDX_CHECK(func) \
{ \
	if ((func) == -1) { \
		throw ::sys::bad_call(__FILE__, __LINE__, __func__); \
	} \
}

/**
\brief
Check if \p func equals \p ret and throw \link sys::bad_call\endlink
with error code and error location.
\ingroup macros
*/
#define UNISTDX_CHECK2(func, ret) \
{ \
	if ((func) == (ret)) { \
		throw ::sys::bad_call(__FILE__, __LINE__, __func__); \
	} \
}

/**
\brief
Check if \p func equals \p ret and throw \link sys::bad_call\endlink
with error code and error location unless \man{errno,3} equals \p good_err.
\ingroup macros
*/
#define UNISTDX_CHECK_IF_NOT(good_err, func) \
{ \
	if ((func) == -1 && errno != (good_err)) { \
		throw ::sys::bad_call(__FILE__, __LINE__, __func__); \
	} \
}

/**
\brief
Check if \p func equals -1 and throw \link sys::bad_call\endlink
with error code and error location unless \man{errno,3} equals \c EAGAIN
or \c EINPROGRESS. In that case set \p func to 0.
\ingroup macros
*/
#define UNISTDX_CHECK_IO(func) \
{ \
	if (func == -1) { \
		if (errno != EAGAIN && errno != EINPROGRESS) { \
			throw ::sys::bad_call(__FILE__, __LINE__, __func__); \
		} \
		func = 0; \
	} \
}

namespace sys {

	/**
	\brief
	A \link std::system_error\endlink that records file, line and function where
	the exception was thrown.
	\date 2018-05-21
	\author Ivan Gankevich
	*/
	class bad_call: public std::system_error {

	public:

		/// Construct the error with precise location where it was thrown.
		inline
		bad_call(const char* file, const int line, const char* function) noexcept:
		std::system_error(errno, std::generic_category()),
		_file(file), _line(line), _function(function)
		{}

		friend std::ostream&
		operator<<(std::ostream& out, const bad_call& rhs);

	private:
		const char* _file;
		const int _line;
		const char* _function;
	};

	/// Output error message prefixed by the location where it was thrown.
	std::ostream&
	operator<<(std::ostream& out, const bad_call& rhs);

}

#endif // vim:filetype=cpp
