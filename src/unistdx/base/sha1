#ifndef UNISTDX_BASE_SHA1
#define UNISTDX_BASE_SHA1

#include <cstdint>

namespace sys {

	class sha1 {

	private:
		union {
			unsigned char _block[64];
			uint32_t _words[80];
			uint64_t _dwords[8];
		};
		union {
			uint32_t _digest[5];
			unsigned char _bytes[20];
		};
		unsigned char* _blockptr;
		std::size_t _length = 0;

	public:

		inline
		sha1() noexcept:
		_digest{0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0},
		_blockptr{_block}
		{}

		inline void
		put(const char* first, std::size_t n) {
			this->xput(first, first+n, n);
		}

		inline void
		put(const char* first, const char* last) {
			this->xput(first, last, last-first);
		}

		inline void
		compute() noexcept {
			if (this->_blockptr != this->block_end()) {
				this->pad_block();
			}
		}

		inline void
		digest(char* result) noexcept {
			for (int i=0; i<20; ++i) {
				result[i] = this->_bytes[i];
			}
		}

		inline void
		digest(uint32_t* result) noexcept {
			for (int i=0; i<5; ++i) {
				result[i] = this->_digest[i];
			}
		}

		inline const uint32_t*
		digest() const noexcept {
			return this->_digest;
		}

		inline const unsigned char*
		digest_bytes() const noexcept {
			return this->_bytes;
		}

	private:

		void
		xput(const char* s, const char* sn, std::size_t n);

		void
		process_block() noexcept;

		void
		pad_block() noexcept;

		inline unsigned char*
		block_begin() noexcept {
			return this->_block;
		}

		inline unsigned char*
		block_end() noexcept {
			return this->_block + 64;
		}

	};

}

#endif // vim:filetype=cpp
