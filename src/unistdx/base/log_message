#ifndef UNISTDX_BASE_LOG_MESSAGE
#define UNISTDX_BASE_LOG_MESSAGE

#include <cassert>

#include <unistdx/io/sysstream>

namespace sys {

	/**
	\brief Write formatted log message.
	\date 2018-05-22
	\author Ivan Gankevich
	\ingroup base
	\details
	\arg The message is buffered, so it is safe to use this class
	in multi-threaded programme.
	\arg Message arguments are inserted using their output operators.
	\arg Insertion location is determined by underscore, or \c spec character.
	\arg Every message is prefixed by abstract name.
	It can be object name, class name or any other identified that distinguishes
	message origin.
	\arg Message names are right-aligned which makes log look like chat, where
	different subsystems talk to each other.
	\arg Message is logged in destructor.
	*/
	class log_message {

	private:
		osysstream _str;
		std::ostream& _log;
		char _spec = '_';

	public:

		/**
		\brief Create log message.
		\date 2018-05-22
		\author Ivan Gankevich
		\details
		Create log message with name \p name, argument marker \p spec,
		formatted text \p fmt, and arguments \p tokens, that will be
		sent to stream \p rhs when destructor is called.
		*/
		template<class ... Args>
		explicit
		log_message(
			std::ostream& rhs,
			const char* name,
			char spec,
			const char* fmt,
			const Args& ... tokens
		):
		_log(rhs),
		_spec(spec) {
			assert(name);
			assert(fmt);
			this->write_name(name);
			this->format_msg(fmt, tokens ...);
		}

		/**
		\brief Create log message.
		\date 2018-05-22
		\author Ivan Gankevich
		\details
		Create log message with name \p name, argument marker '_',
		formatted text \p fmt, and arguments \p tokens, that will be
		sent to stream \p rhs when destructor is called.
		*/
		template<class ... Args>
		explicit
		log_message(
			std::ostream& rhs,
			const char* name,
			const char* fmt,
			const Args& ... tokens
		):
		log_message(rhs, name, '_', fmt, tokens ...)
		{}

		/**
		\brief Create log message.
		\date 2018-05-22
		\author Ivan Gankevich
		\details
		Create log message with name \p name, argument marker '_',
		formatted text \p fmt, and arguments \p tokens, that will be
		sent to standard error stream when destructor is called.
		*/
		template<class ... Args>
		explicit
		log_message(const char* name, const char* fmt, const Args& ... tokens):
		log_message(name, '_', fmt, tokens ...)
		{}

		/**
		\brief Create log message.
		\date 2018-05-22
		\author Ivan Gankevich
		\details
		Create log message with name \p name, argument marker \p spec,
		formatted text \p fmt, and arguments \p tokens, that will be
		sent to standard error stream when destructor is called.
		*/
		template<class ... Args>
		explicit
		log_message(
			const char* name,
			char spec,
			const char* fmt,
			const Args& ... tokens
		):
		_str(STDERR_FILENO, 256),
		_log(_str),
		_spec(spec) {
			assert(name);
			assert(fmt);
			this->write_name(name);
			this->format_msg(fmt, tokens ...);
		}

		~log_message();

		/// Insert object \p rhs to log message stream.
		template<class T>
		std::ostream&
		operator<<(const T& rhs) {
			return this->_log << rhs;
		}

		/// Insert output stream manipulator \p rhs to log message stream.
		inline std::ostream&
		operator<<(std::ostream& (*rhs)(std::ostream&)) {
			return this->_log << rhs;
		}

		/// Access log message stream.
		inline std::ostream&
		out() noexcept {
			return this->_log;
		}

	private:

		inline void
		format_msg(const char* s) {
			this->_str << s;
		}

		template<class T, class ... Args>
		void
		format_msg(const char* s, const T& value, const Args& ... args) {
			const char* olds = s;
			while (*s && *s != this->_spec) {
				++s;
			}
			this->_log.rdbuf()->sputn(olds, s - olds);
			this->_log << value;
			if (*s) {
				this->format_msg(++s, args ...);
			}
		}

		inline void
		write_name(const char* name) {
			this->_log.width(10);
			this->_log.setf(std::ios::right, std::ios::adjustfield);
			this->_log << name << ": ";
		}

	};

}

#endif // vim:filetype=cpp
