#ifndef UNISTDX_BASE_PACKETBUF
#define UNISTDX_BASE_PACKETBUF

#include <cassert>
#include <streambuf>
#if !defined(NDEBUG) && defined(UNISTDX_DEBUG_PACKETBUF)
#define UNISTDX_FUNC , __func__
#include <iomanip>
#include <ostream>
#include <sstream>
#include <unistdx/base/log_message>
#else
#define UNISTDX_FUNC
#endif

namespace sys {

	template<class Ch, class Tr=std::char_traits<Ch> >
	class basic_packetbuf: public virtual std::basic_streambuf<Ch,Tr> {

	public:
		using typename std::basic_streambuf<Ch,Tr>::pos_type;
		using typename std::basic_streambuf<Ch,Tr>::off_type;
		using typename std::basic_streambuf<Ch,Tr>::char_type;
		using typename std::basic_streambuf<Ch,Tr>::traits_type;

	private:
		enum struct state_type {
			initial,
			header_is_ready,
			payload_is_ready
		};

	private:
		pos_type _opacketpos = 0;
		pos_type _ipacketpos = 0;
		pos_type _ipayloadpos = 0;
		std::streamsize _ipacketsize = 0;
		std::streamsize _oheadersize = 0;
		// Saved position of egptr that may be larger than ipacket_end.
		pos_type _oldendpos = 0;
		state_type _state = state_type::initial;
		/// Output packet finished.
		bool _ofinished = false;

	public:

		inline
		basic_packetbuf():
		std::basic_streambuf<Ch,Tr>()
		{}

		virtual
		~basic_packetbuf() = default;

		basic_packetbuf(basic_packetbuf&&) = delete;

		basic_packetbuf(const basic_packetbuf&) = delete;

		basic_packetbuf&
		operator=(const basic_packetbuf&) = delete;

		basic_packetbuf&
		operator=(basic_packetbuf&&) = delete;

		virtual bool
		handshake() {
			return true;
		}

		void
		begin_packet() {
			this->set_opacket(this->pptr() - this->pbase());
			this->put_header();
			const pos_type cur = this->pptr() - this->pbase();
			this->_oheadersize = cur - this->_opacketpos;
			this->_ofinished = false;
		}

		void
		end_packet() {
			const std::streamsize ps = this->opacketsize();
			const std::streamsize hs = this->_oheadersize;
			// check if the header size has changed
			// depending on the length of the payload
			const std::streamsize new_hs = this->overwrite_header(ps);
			assert(new_hs <= hs);
			if (new_hs < hs) {
				const std::streamsize delta = new_hs - hs;
				char_type* src = this->opacket_begin();
				// move payload to match new header size
				traits_type::move(src + new_hs, src + hs, ps - hs);
				// advance put pointer
				this->pbump(delta);
			}
			this->_ofinished = true;
		}

		void
		cancel_packet() {
			if (!this->_ofinished) {
				pos_type offset = this->pptr() - this->pbase();
				this->pbump(this->_opacketpos - offset);
				assert(this->pbase() + this->_opacketpos == this->pptr());
				this->_opacketpos = 0;
			}
		}

		bool
		read_packet() {
			state_type old_state;
			do {
				old_state = this->_state;
				switch (this->_state) {
				case state_type::initial: this->getheader(); break;
				case state_type::header_is_ready: this->getpayload(); break;
				case state_type::payload_is_ready:
					const bool empty_payload = this->ipayloadsize() == 0;
					this->finish();
					if (empty_payload) {
						return true;
					}
					break;
				}
			} while (old_state != this->_state);
			return this->_state == state_type::payload_is_ready;
		}

		void
		skip_packet() {
			if (this->_state == state_type::payload_is_ready) {
				this->reset_ipacket();
			}
		}

		bool
		dirty() const noexcept {
			return this->pptr() != this->pbase();
		}

	protected:

		virtual void
		put_header() {}

		/*
		@param ps packet size
		@return header size
		*/
		virtual std::streamsize
		overwrite_header(std::streamsize ps) {
			return this->_oheadersize;
		}

		virtual bool
		xgetheader(
			std::streamsize&,
			std::streamsize& payload_size
		) {
			payload_size = this->egptr() - this->gptr();
			return true;
		}

		virtual void
		on_payload() {}

		inline state_type
		state() const noexcept {
			return this->_state;
		}

		inline char_type*
		ipayload_begin() noexcept {
			return this->eback() + this->_ipayloadpos;
		}

		inline char_type*
		ipayload_end() noexcept {
			return this->ipayload_begin() + this->ipayloadsize();
		}

		inline pos_type
		ipayloadpos() const noexcept {
			return this->_ipayloadpos;
		}

		inline std::streamsize
		ipayloadsize() const noexcept {
			return this->_ipacketsize - (this->_ipayloadpos -
			                             this->_ipacketpos);
		}

		inline char_type*
		ipacket_begin() const noexcept {
			return this->eback() + this->_ipacketpos;
		}

		inline char_type*
		ipacket_end() const noexcept {
			return this->ipacket_begin() + this->_ipacketsize;
		}

		inline pos_type
		ipacketpos() const noexcept {
			return this->_ipacketpos;
		}

		inline std::streamsize
		ipacketsize() const noexcept {
			return this->_ipacketsize;
		}

		inline char_type*
		opacket_begin() const noexcept {
			return this->pbase() + this->_opacketpos;
		}

		inline char_type*
		opacket_end() const noexcept {
			return this->pptr();
		}

		inline pos_type
		opacketpos() const noexcept {
			return this->_opacketpos;
		}

		inline std::streamsize
		opacketsize() const noexcept {
			return this->opacket_end() - this->opacket_begin();
		}

		inline std::streamsize
		oheadersize() const noexcept {
			return this->_oheadersize;
		}

		inline void
		set_oheader(std::streamsize size) noexcept {
			this->_oheadersize = size;
		}

		inline void
		set_opacket(pos_type pos1) noexcept {
			this->_opacketpos = pos1;
		}

		inline void
		set_ipacket(pos_type pos1, pos_type pos2, std::streamsize n) noexcept {
			this->_ipacketpos = pos1;
			this->_ipayloadpos = pos2;
			this->_ipacketsize = n;
			assert(this->_ipacketpos <= this->_ipayloadpos);
			assert(this->_ipayloadpos <= this->_ipacketpos + pos_type(n));
		}

		inline void
		seek_ipayloadpos(off_type off) noexcept {
			assert(this->eback() <= this->ipayload_begin() + off);
			assert(this->ipayload_begin() + off <= this->egptr());
			this->setg(
				this->eback(),
				this->ipayload_begin() + off,
				this->egptr()
			);
		}

		template<class Ch1, class Tr1>
		friend void
		append_payload(
			basic_packetbuf<Ch1,Tr1>& buf,
			basic_packetbuf<Ch1,Tr1>& rhs
		);

	private:
		void
		getheader() {
			std::streamsize hs = 0;
			std::streamsize payload_size = 0;
			if (this->xgetheader(hs, payload_size)) {
				const std::streamsize ps = hs + payload_size;
				const pos_type p = this->gptr() - this->eback();
				this->set_ipacket(p, p + pos_type(hs), ps);
				this->gbump(hs);
				this->setstate(state_type::header_is_ready UNISTDX_FUNC);
			}
		}

		void
		getpayload() {
			const pos_type endpos = this->egptr() - this->eback();
			if (this->_oldendpos < endpos) {
				this->_oldendpos = endpos;
			}
			if (this->egptr() >= this->ipacket_end()) {
				this->setg(
					this->eback(),
					this->ipayload_begin(),
					this->ipayload_end()
				);
				this->setstate(state_type::payload_is_ready UNISTDX_FUNC);
				this->on_payload();
			}
		}

		void
		finish() {
			if (this->gptr() == this->ipayload_end()) {
				this->reset_ipacket();
			}
		}

		void
		reset_ipacket() {
			const pos_type endpos = this->egptr() - this->eback();
			if (this->_oldendpos > endpos) {
				this->setg(
					this->eback(),
					this->ipayload_end(),
					this->eback() + this->_oldendpos
				);
			}
			this->set_ipacket(0, 0, 0);
			this->_oldendpos = 0;
			this->setstate(state_type::initial UNISTDX_FUNC);
		}

		#if !defined(NDEBUG) && defined(UNISTDX_DEBUG_PACKETBUF)
		friend std::ostream&
		operator<<(std::ostream& out, state_type rhs) {
			switch (rhs) {
			case state_type::initial: out << "initial"; break;
			case state_type::header_is_ready: out << "header_is_ready"; break;
			case state_type::payload_is_ready: out << "payload_is_ready"; break;
			default: break;
			}
			return out;
		}

		class transition {

		private:
			const char* _where;
			state_type _oldstate, _newstate;
			basic_packetbuf& _buf;

		public:
			inline
			transition(
				const char* where,
				state_type olds,
				state_type news,
				basic_packetbuf& buf
			):
			_where(where), _oldstate(olds), _newstate(news), _buf(buf)
			{}

			friend std::ostream&
			operator<<(std::ostream& out, const transition& rhs) {
				std::stringstream msg;
				msg << rhs._oldstate << "->" << rhs._newstate;
				return out
				       << std::setw(20) << std::left << rhs._where
				       << std::setw(40) << std::left << msg.str() << rhs._buf;
			}

		};

		void
		setstate(state_type rhs, const char* where) {
			const state_type olds = this->_state;
			this->_state = rhs;
			sys::log_message(
				"packetbuf",
				"_",
				transition(where, olds, this->_state, *this)
			);
		}

		void
		dump_state(std::ostream& out) {
			out << "put={" << this->pptr() - this->pbase() << ',' <<
			    this->epptr() - this->pbase() << '}'
			    << ",get={" << this->gptr() - this->eback() << ',' <<
			    this->egptr() - this->eback() << '}'
			    << ",packet={"
			    << this->ipacket_begin() - this->eback() << ','
			    << this->ipayload_begin() - this->eback() << ','
			    << this->ipacket_end() - this->eback()
			    << '}'
			    << ",save_egptr=" << this->_oldendpos;
		}

		friend std::ostream&
		operator<<(std::ostream& out, basic_packetbuf& rhs) {
			rhs.dump_state(out);
			return out;
		}

		#else
		inline void
		setstate(state_type rhs) {
			this->_state = rhs;
		}

		#endif // if !defined(NDEBUG) && defined(UNISTDX_DEBUG_PACKETBUF)

	};

	template<class Ch, class Tr>
	void
	append_payload(basic_packetbuf<Ch,Tr>& buf, basic_packetbuf<Ch,Tr>& rhs) {
		const std::streamsize n = rhs.ipayloadsize();
		buf.sputn(rhs.ipayload_begin(), n);
		rhs.seek_ipayloadpos(n);
	}

	typedef basic_packetbuf<char> packetbuf;

}

#undef UNISTDX_FUNC

#endif // vim:filetype=cpp
