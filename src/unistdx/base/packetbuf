#ifndef UNISTDX_BASE_PACKETBUF
#define UNISTDX_BASE_PACKETBUF

#include <cassert>
#include <stdexcept>
#include <streambuf>

#include <unistdx/bits/no_copy_and_move>

#if !defined(NDEBUG) && defined(UNISTDX_DEBUG_PACKETBUF)
#define UNISTDX_FUNC , __func__
#include <iomanip>
#include <ostream>
#include <sstream>
#include <unistdx/bits/debug_message>
#else
#define UNISTDX_FUNC
#endif

namespace sys {

	/// Object that stores streambuf internal state.
	template<class Ch>
	struct streamptr {
		/// Character type.
		typedef Ch char_type;
		/// Pointer to the beginning of get area.
		char_type* _eback = nullptr;
		/// Pointer to the current character of get area.
		char_type* _gptr = nullptr;
		/// Pointer to the end of get area.
		char_type* _egptr = nullptr;
	};

	template<class Ch, class Tr=std::char_traits<Ch>>
	class basic_ipacket_guard;

	/**
	\brief
	Stream buffer that can reads/writes data in packets with arbitrary header.
	\date 2018-05-22
	\author Ivan Gankevich
	\ingroup streambuf
	\arg By default header size is nought, and packet buffer works
	as a regular stream buffer.
	*/
	template<class Ch, class Tr=std::char_traits<Ch>>
	class basic_packetbuf: public virtual std::basic_streambuf<Ch,Tr> {

	public:
		/// Incoming packet guard type.
		typedef basic_ipacket_guard<Ch,Tr> ipacket_guard;

	public:
		using typename std::basic_streambuf<Ch,Tr>::off_type;
		using typename std::basic_streambuf<Ch,Tr>::char_type;
		using typename std::basic_streambuf<Ch,Tr>::traits_type;

	private:
		enum struct state_type {
			initial,
			header_is_ready,
			payload_is_ready
		};

	private:
		off_type _opacketpos = 0;
		off_type _ipacketpos = 0;
		off_type _ipayloadpos = 0;
//		std::streamsize _iheadersize = 0;
		std::streamsize _ipacketsize = 0;
		std::streamsize _oheadersize = 0;
		state_type _state = state_type::initial;
		/// Output packet finished.
		bool _ofinished = false;

	#if !defined(NDEBUG)
	protected:
		/// Packet buffer name for debugging.
		const char* _name = "packetbuf";
	#endif

	public:

		inline
		basic_packetbuf():
		std::basic_streambuf<Ch,Tr>()
		{}

		virtual
		~basic_packetbuf() = default;

		UNISTDX_NO_COPY_AND_MOVE(basic_packetbuf)

		/**
		Perform protocol-specific handshake. Does nothing by default.
		\return true, if handshake was successful.
		*/
		virtual bool
		handshake() {
			return true;
		}

		/// Start writing a packet by appending an empty header.
		void
		begin_packet() {
			this->set_opacket(this->pptr_offset());
			this->put_header();
			this->_oheadersize = this->pptr_offset() - this->_opacketpos;
			this->_ofinished = false;
		}

		/**
		Finish writing the packet by updating its header with
		actual packet size.
		*/
		void
		end_packet() {
			const std::streamsize ps = this->opacketsize();
			const std::streamsize hs = this->_oheadersize;
			// check if the header size has changed
			// depending on the length of the payload
			const std::streamsize new_hs = this->overwrite_header(ps);
			assert(new_hs <= hs);
			if (new_hs < hs) {
				const std::streamsize delta = new_hs - hs;
				char_type* src = this->opacket_begin();
				// move payload to match new header size
				traits_type::move(src + new_hs, src + hs, ps - hs);
				// advance put pointer
				this->pbump(delta);
			}
			#if !defined(NDEBUG) && defined(UNISTDX_DEBUG_PACKETBUF)
			sys::debug_message(
				this->_name,
				"end {hs=_,ps=_}",
				hs,
				ps-hs
			);
			#endif
			this->_ofinished = true;
		}

		/// Cancel writing a packet, resetting put buffer position.
		void
		cancel_packet() {
			if (!this->_ofinished) {
				off_type offset = this->pptr() - this->pbase();
				this->pbump(this->_opacketpos - offset);
				assert(this->pbase() + this->_opacketpos == this->pptr());
				this->_opacketpos = 0;
			}
		}

		/// Read the packet and update packet parsing state.
		bool
		read_packet() {
			state_type old_state;
			do {
				old_state = this->_state;
				switch (this->_state) {
				case state_type::initial: this->getheader(); break;
				case state_type::header_is_ready: this->getpayload(); break;
				case state_type::payload_is_ready:
					const bool empty_payload = this->ipayloadsize() == 0;
					this->finish();
					if (empty_payload) {
						return true;
					}
					break;
				}
			} while (old_state != this->_state);
			return this->_state == state_type::payload_is_ready;
		}

		/**
		Move to the next input packet, if the payload of the current packet is ready.
		*/
		void
		skip_packet() {
			if (this->_state == state_type::payload_is_ready) {
				this->reset_ipacket();
			}
		}

		/// Returns true, if put buffer is non-empty.
		inline bool
		dirty() const noexcept {
			return this->pptr() != this->pbase();
		}

		/// Returns the number of remaining bytes in put buffer.
		inline std::streamsize
		remaining() const noexcept {
			return this->pptr() - this->pbase();
		}

		/// Returns the number of available bytes in get buffer.
		inline std::streamsize
		available() const noexcept {
			return this->egptr() - this->gptr();
		}

		/// Get pointer offset within the payload.
		inline std::streamsize
		ipayload_offset() const noexcept {
			return this->gptr() - this->ipayload_begin();
		}

		template<class Ch2, class Tr2> friend class basic_ipacket_guard;

		#if !defined(NDEBUG)
		/// Set packet buffer name for debugging.
		inline void
		set_name(const char* rhs) noexcept {
			this->_name = rhs;
		}
		#endif

		/**
		Returns true if packet buffer can be compacted without
		ruining the state which might have been save by subclasses.
		*/
		inline bool
		is_safe_to_compact() const noexcept {
			return this->_state == state_type::initial;
		}

		/// Returns the pointer to the beginning of incoming packet.
		inline char_type*
		ipacket_begin() noexcept {
			return this->eback() + this->_ipacketpos;
		}

		/// Returns the pointer to the beginning of incoming packet.
		inline const char_type*
		ipacket_begin() const noexcept {
			return this->eback() + this->_ipacketpos;
		}

		/// Returns the pointer to the end of incoming packet.
		inline char_type*
		ipacket_end() noexcept {
			return this->ipacket_begin() + this->_ipacketsize;
		}

		/// Returns the pointer to the end of incoming packet.
		inline const char_type*
		ipacket_end() const noexcept {
			return this->ipacket_begin() + this->_ipacketsize;
		}

		/// The size of the incoming packet.
		inline std::streamsize
		ipacketsize() const noexcept {
			return this->_ipacketsize;
		}

		/// Returns the pointer to the beginning of incoming packet payload.
		inline char_type*
		ipayload_begin() noexcept {
			return this->eback() + this->_ipayloadpos;
		}

		/// Returns the pointer to the beginning of incoming packet payload.
		inline const char_type*
		ipayload_begin() const noexcept {
			return this->eback() + this->_ipayloadpos;
		}

		/// Returns the pointer to the current byte of incoming packet payload.
		inline char_type*
		ipayload_cur() noexcept {
			return this->gptr();
		}

		/// Returns the pointer to the current byte of incoming packet payload.
		inline const char_type*
		ipayload_cur() const noexcept {
			return this->gptr();
		}

		/// Returns the pointer to the end of incoming packet payload.
		inline char_type*
		ipayload_end() noexcept {
			return this->ipayload_begin() + this->ipayloadsize();
		}

		/// Returns the pointer to the end of incoming packet payload.
		inline const char_type*
		ipayload_end() const noexcept {
			return this->ipayload_begin() + this->ipayloadsize();
		}

		/// Returns the size of the incoming packet payload.
		inline std::streamsize
		ipayloadsize() const noexcept {
			return this->_ipacketsize - (this->_ipayloadpos -
			                             this->_ipacketpos);
		}

		/**
		Seeks get buffer position from the beginning of input packet payload.
		*/
		inline void
		seek_ipayloadpos(off_type off) noexcept {
			assert(this->eback() <= this->ipayload_begin() + off);
			assert(this->ipayload_begin() + off <= this->egptr());
			this->setg(
				this->eback(),
				this->ipayload_begin() + off,
				this->egptr()
			);
		}

	protected:

		/**
		Write packet header into the put buffer. Does nothing by default.
		The method is called in \link begin_packet\endlink to write intiial
		packet header when actual packet size is not known.
		*/
		virtual void
		put_header() {}

		/**
		\brief Overwrite packet header when actual packet size is known.
		The argument is packet size.
		\return header size
		*/
		virtual std::streamsize
		overwrite_header(std::streamsize) {
			return this->_oheadersize;
		}

		/**
		Read packet header and return header and payload size.
		\param[out] header_size the size of packet header
		\param[out] payload_size the size of packet payload
		\return true, if there are enough bytes to parse the header
		*/
		virtual bool
		xgetheader(
			std::streamsize& header_size,
			std::streamsize& payload_size
		) {
			payload_size = this->egptr() - this->gptr();
			return true;
		}

		/**
		This function is called when payload becomes ready. Does nothing
		by default.
		*/
		virtual void
		on_payload() {}

		/// Packet parsing state.
		inline state_type
		state() const noexcept {
			return this->_state;
		}

		/**
		Offset of the first incoming packet payload byte
		relative to \c eback().
		*/
		inline off_type
		ipayloadpos() const noexcept {
			return this->_ipayloadpos;
		}

		/**
		Offset of the first incoming packet byte
		relative to \c eback().
		*/
		inline off_type
		ipacketpos() const noexcept {
			return this->_ipacketpos;
		}

		/// Pointer to the beginning of the outgoing packet.
		inline char_type*
		opacket_begin() const noexcept {
			return this->pbase() + this->_opacketpos;
		}

		/// Pointer to the end of the outgoing packet.
		inline char_type*
		opacket_end() const noexcept {
			return this->pptr();
		}

		/**
		Offset of the first outgoing packet byte
		relative to \c pbase().
		*/
		inline off_type
		opacketpos() const noexcept {
			return this->_opacketpos;
		}

		/// The size of the outgoing packet in bytes.
		inline std::streamsize
		opacketsize() const noexcept {
			return this->opacket_end() - this->opacket_begin();
		}

		/// Get outgoing packet header size.
		inline std::streamsize
		oheadersize() const noexcept {
			return this->_oheadersize;
		}

		/// Set outgoing packet header size.
		inline void
		set_oheader(std::streamsize size) noexcept {
			this->_oheadersize = size;
		}

		/// Set outgoing packet offset relative to \c pbase().
		inline void
		set_opacket(off_type pos1) noexcept {
			this->_opacketpos = pos1;
		}

		/**
		Set incoming packet offset to \p pos1, payload offset to \p pos2
		and size to \p n.
		*/
		inline void
		set_ipacket(off_type pos1, off_type pos2, std::streamsize n) noexcept {
			this->_ipacketpos = pos1;
			this->_ipayloadpos = pos2;
			this->_ipacketsize = n;
			assert(this->_ipacketpos <= this->_ipayloadpos);
			assert(this->_ipayloadpos <= this->_ipacketpos + n);
		}

		/**
		Append full payload of the packet from \p dest to \p src.
		Only payload is copied.
		*/
		template<class Ch1, class Tr1>
		friend void
		append_payload(
			basic_packetbuf<Ch1,Tr1>& buf,
			basic_packetbuf<Ch1,Tr1>& rhs,
			std::streamsize off
		);

	private:
		void
		getheader() {
			std::streamsize hs = 0;
			std::streamsize payload_size = 0;
			#if !defined(NDEBUG) && defined(UNISTDX_DEBUG_PACKETBUF)
			sys::debug_message(this->_name, "available _", available());
			#endif
			if (this->xgetheader(hs, payload_size)) {
				#if !defined(NDEBUG) && defined(UNISTDX_DEBUG_PACKETBUF)
				sys::debug_message(this->_name, "_ hs=_,ps=_", __func__, hs, payload_size);
				#endif
				if (hs < 0) {
					throw std::invalid_argument("header size is less than nought");
				}
				if (payload_size < 0) {
					throw std::invalid_argument("payload size is less than nought");
				}
				const std::streamsize ps = hs + payload_size;
				const off_type p = this->gptr() - this->eback();
				this->set_ipacket(p, p + hs, ps);
				//this->_iheadersize = hs;
				this->gbump(hs);
				this->setstate(state_type::header_is_ready UNISTDX_FUNC);
			}
		}

		void
		getpayload() {
			if (this->egptr() >= this->ipacket_end()) {
				//this->gbump(this->_iheadersize);
				this->setstate(state_type::payload_is_ready UNISTDX_FUNC);
				this->on_payload();
			}
		}

		void
		finish() {
			if (this->gptr() == this->ipayload_end()) {
				this->reset_ipacket();
			}
		}

		void
		reset_ipacket() {
			this->set_ipacket(0, 0, 0);
			this->setstate(state_type::initial UNISTDX_FUNC);
		}

		#if !defined(NDEBUG) && defined(UNISTDX_DEBUG_PACKETBUF)
		friend std::ostream&
		operator<<(std::ostream& out, state_type rhs) {
			switch (rhs) {
			case state_type::initial: out << "initial"; break;
			case state_type::header_is_ready: out << "header_is_ready"; break;
			case state_type::payload_is_ready: out << "payload_is_ready"; break;
			default: break;
			}
			return out;
		}

		class transition {

		private:
			const char* _where;
			state_type _oldstate, _newstate;
			basic_packetbuf& _buf;

		public:
			inline
			transition(
				const char* where,
				state_type olds,
				state_type news,
				basic_packetbuf& buf
			):
			_where(where), _oldstate(olds), _newstate(news), _buf(buf)
			{}

			friend std::ostream&
			operator<<(std::ostream& out, const transition& rhs) {
				std::stringstream msg;
				msg << rhs._oldstate << "->" << rhs._newstate;
				return out
				       << std::setw(20) << std::left << rhs._where
				       << std::setw(40) << std::left << msg.str() << rhs._buf;
			}

		};

		void
		setstate(state_type rhs, const char* where) {
			const state_type olds = this->_state;
			this->_state = rhs;
			sys::debug_message(
				this->_name,
				"_",
				transition(where, olds, this->_state, *this)
			);
		}

		void
		dump_state(std::ostream& out) {
			out << "put={" << this->pptr() - this->pbase() << ',' <<
			    this->epptr() - this->pbase() << '}'
			    << ",get={" << this->gptr() - this->eback() << ',' <<
			    this->egptr() - this->eback() << '}'
			    << ",packet={"
			    << this->ipacket_begin() - this->eback() << ','
			    << this->ipayload_begin() - this->eback() << ','
			    << this->ipacket_end() - this->eback()
			    << '}';
		}

		friend std::ostream&
		operator<<(std::ostream& out, basic_packetbuf& rhs) {
			rhs.dump_state(out);
			return out;
		}

		#else
		inline void
		setstate(state_type rhs) {
			this->_state = rhs;
		}

		#endif // if !defined(NDEBUG) && defined(UNISTDX_DEBUG_PACKETBUF)

		void
		setgptr(const streamptr<Ch>& rhs) {
			assert(this->gptr() <= this->ipayload_end());
			assert(this->egptr() <= rhs._egptr);
			this->setg(this->eback(), this->ipayload_end(), rhs._egptr);
		}

		void
		getgptr(streamptr<Ch>& rhs) {
			rhs._eback = this->eback();
			rhs._gptr = this->gptr();
			rhs._egptr = this->egptr();
		}

		/// Start reading payload. This method limits how many bytes
		/// can be read with a call to \c setg().
		void
		begin_payload() {
			if (this->_state != state_type::payload_is_ready) {
				return;
			}
			this->setg(
				this->eback(),
				this->ipayload_begin(),
				this->ipayload_end()
			);
		}


		inline off_type
		pptr_offset() const {
			return this->pptr() - this->pbase();
		}

	};

	/**
	Append full payload of the packet from \p dest to \p src.
	Only payload is copied.
	*/
	template<class Ch, class Tr>
	void
	append_payload(
		basic_packetbuf<Ch, Tr>& dest,
		basic_packetbuf<Ch, Tr>& src,
		std::streamsize off=0
	) {
		const std::streamsize n = src.ipayloadsize();
		dest.sputn(src.ipayload_begin()+off, n-off);
		src.seek_ipayloadpos(n);
	}

	/// Alias to basic_packetbuf<char>.
	typedef basic_packetbuf<char> packetbuf;

	/**
	\brief Guard object that preserves packet buffer state upon failure.
	\date 2018-05-22
	\author Ivan Gankevich
	\ingroup guard
	*/
	template<class Ch, class Tr>
	class basic_ipacket_guard {

	private:
		typedef Ch char_type;
		typedef streamptr<Ch> ptr_type;
		typedef basic_packetbuf<Ch,Tr> buf_type;

	private:
		buf_type* _buf;
		ptr_type _ptrs;

	public:

		/**
		Construct incoming packet guard for packet buffer \p buf,
		save buffer state and set get buffer pointers to limit
		reading only to payload part of the packet buffer.
		*/
		explicit
		basic_ipacket_guard(buf_type* buf):
		_buf(buf)
		{
			this->_buf->getgptr(this->_ptrs);
			this->_buf->begin_payload();
		}

		/**
		Destroy incoming packet guard, restore buffer state
		and skip remaining payload bytes (if any).
		*/
		~basic_ipacket_guard() {
			this->_buf->setgptr(this->_ptrs);
			this->_buf->skip_packet();
		}

		UNISTDX_NO_COPY_AND_MOVE(basic_ipacket_guard)

	};

}

#undef UNISTDX_FUNC

#endif // vim:filetype=cpp
