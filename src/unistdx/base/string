#ifndef UNISTDX_BASE_STRING
#define UNISTDX_BASE_STRING

#include <string>

namespace sys {

    /// \brief Immutable string with unknown size.
    class c_string {

    public:
        using pointer = char*;
        using const_pointer = const char*;
        using size_type = size_t;

    private:
        const_pointer _data{};

    public:

        inline
        c_string(const_pointer data) noexcept:
        _data(data) {}

        template <class Tr, class Alloc> inline
        c_string(const std::basic_string<char,Tr,Alloc>& str) noexcept:
        _data(str.data()) {}

        inline const_pointer data() const noexcept { return this->_data; }
        inline operator const_pointer() const noexcept { return this->_data; }

        inline size_type size() const noexcept {
            return std::char_traits<char>::length(data());
        }

    };

    /// \brief Immutable string with known size.
    class const_string {

    public:
        using pointer = char*;
        using const_pointer = const char*;
        using size_type = size_t;

    private:
        const_pointer _data{};
        size_type _size{};

    public:

        inline
        const_string(const_pointer data, size_type size) noexcept:
        _data(data), _size(size) {}

        inline
        const_string(const_pointer data) noexcept:
        const_string(data, std::char_traits<char>::length(data)) {}

        template <class Tr, class Alloc> inline
        const_string(const std::basic_string<char,Tr,Alloc>& str) noexcept:
        const_string(str.data(), str.size()) {}

        inline const_pointer data() const noexcept { return this->_data; }
        inline operator const_pointer() const noexcept { return this->_data; }
        inline size_type size() const noexcept { return this->_size; }
        inline const_pointer begin() const noexcept { return data(); }
        inline const_pointer end() const noexcept { return data()+size(); }

    };

}

#endif // vim:filetype=cpp
