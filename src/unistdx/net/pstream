#ifndef UNISTDX_NET_PSTREAM
#define UNISTDX_NET_PSTREAM

#include <cassert>
#include <limits>
#include <stdexcept>

#include <unistdx/base/packetbuf>
#include <unistdx/base/types>
#include <unistdx/config>
#include <unistdx/net/bytes>

namespace sys {

	template<class Ch, class Tr=std::char_traits<Ch>, class Size=u32>
	struct basic_pstream {

		typedef basic_packetbuf<Ch,Tr> streambuf_type;
		typedef Ch char_type;
		typedef std::basic_string<Ch,Tr> string_type;

		basic_pstream() = default;

		inline explicit
		basic_pstream(streambuf_type* buf):
		_buf(buf) {}

		// @deprecated
		inline void
		flush() {
			this->_buf->pubsync();
		}

		// @deprecated
		inline std::streamsize
		tellp() {
			return this->_buf->pubseekoff(
				0,
				std::ios_base::cur,
				std::ios_base::out
			);
		}

		// @deprecated
		inline std::streamsize
		tellg() {
			return this->_buf->pubseekoff(
				0,
				std::ios_base::cur,
				std::ios_base::in
			);
		}

		inline streambuf_type*
		rdbuf() {
			return this->_buf;
		}

		inline const streambuf_type*
		rdbuf() const {
			return this->_buf;
		}

		inline streambuf_type*
		rdbuf(streambuf_type* rhs) {
			streambuf_type* old = this->_buf;
			this->_buf = rhs;
			return old;
		}

		inline void
		sync() {
			this->_buf->pubsync();
		}

		inline void
		begin_packet() {
			this->_buf->begin_packet();
		}

		inline void
		end_packet() {
			this->_buf->end_packet();
		}

		inline bool
		read_packet() {
			return this->_buf->read_packet();
		}

		inline void
		skip_packet() {
			this->_buf->skip_packet();
		}

		inline void
		cancel_packet() {
			this->_buf->cancel_packet();
		}

		/// Append packet payload starting from the beginning.
		inline void
		append_payload(basic_pstream& rhs) {
			assert(this->_buf);
			assert(rhs._buf);
			::sys::append_payload(*this->_buf, *rhs._buf);
		}

		/// Append packet payload starting from the current position.
		inline void
		append_payload_cur(basic_pstream& src) {
			assert(this->_buf);
			assert(src._buf);
			::sys::append_payload(
				*this->_buf,
				*src._buf,
				src._buf->ipayload_offset()
			);
		}

		inline explicit
		operator bool() const noexcept {
			return true;
		}

		inline bool
		operator!() const noexcept {
			return !operator bool();
		}

		inline basic_pstream&
		operator<<(bool rhs) {
			return this->write(rhs ? char(1) : char(0));
		}

		#define MAKE_INOUT_OPERATOR(tp) \
			inline basic_pstream& \
			operator<<(tp rhs) { \
				return this->write(rhs); \
			} \
			inline basic_pstream& \
			operator>>(tp& rhs) { \
				return this->read(rhs); \
			}

		MAKE_INOUT_OPERATOR(char)
		MAKE_INOUT_OPERATOR(i8)
		MAKE_INOUT_OPERATOR(i16)
		MAKE_INOUT_OPERATOR(i32)
		MAKE_INOUT_OPERATOR(i64)
		MAKE_INOUT_OPERATOR(u8)
		MAKE_INOUT_OPERATOR(u16)
		MAKE_INOUT_OPERATOR(u32)
		MAKE_INOUT_OPERATOR(u64)
		MAKE_INOUT_OPERATOR(f32)
		MAKE_INOUT_OPERATOR(f64)
		#if defined(UNISTDX_HAVE_LONG_DOUBLE)
		MAKE_INOUT_OPERATOR(f128)
		#endif
		MAKE_INOUT_OPERATOR(string_type)

		#undef MAKE_INOUT_OPERATOR

		template<class T>
		inline basic_pstream&
		operator<<(const sys::bytes<T,Ch>& rhs) {
			return this->write(rhs.begin(), rhs.size());
		}

		inline basic_pstream&
		operator>>(bool& rhs) {
			char c = 0;
			this->read(c);
			rhs = c == 1;
			return *this;
		}

		template<class T>
		inline basic_pstream&
		operator>>(sys::bytes<T,Ch>& rhs) {
			return this->read(rhs.begin(), rhs.size());
		}

		inline basic_pstream&
		write(const Ch* buf, std::streamsize n) {
			this->_buf->sputn(buf, n);
			return *this;
		}

		inline basic_pstream&
		read(Ch* buf, std::streamsize n) {
			this->_buf->sgetn(buf, n);
			return *this;
		}

	private:

		template<class T>
		inline basic_pstream&
		write(T rhs) {
			#ifndef IGNORE_ISO_IEC559
			static_assert(
				std::is_integral<T>::value or (
					std::is_floating_point<T>::value and
					std::numeric_limits<T>::is_iec559
				),
				"This system does not support ISO IEC 559"
				" floating point representation for either float, double or long double"
				" types, i.e. there is no portable way of"
				" transmitting floating point numbers over the network"
				" without precision loss. If all computers in the network do not"
				" conform to this standard but represent floating point"
				" numbers exactly in the same way, you can ignore this assertion"
				" by defining IGNORE_ISO_IEC559."
			);
			#endif
			bytes<T,Ch> val = rhs;
			val.to_network_format();
			return this->write(val.begin(), val.size());
		}

		inline basic_pstream&
		write(const string_type& rhs) {
			if (rhs.size() > std::numeric_limits<Size>::max()) {
				throw std::invalid_argument("string is too long");
			}
			Size length = static_cast<Size>(rhs.size());
			this->write(length);
			this->_buf->sputn(rhs.c_str(), length);
			return *this;
		}

		template<class T>
		inline basic_pstream&
		read(T& rhs) {
			sys::bytes<T,Ch> val;
			this->read(val.begin(), val.size());
			val.to_host_format();
			rhs = val;
			return *this;
		}

		inline basic_pstream&
		read(string_type& rhs) {
			Size length = 0;
			this->read(length);
			if (length > std::numeric_limits<typename string_type::size_type>::max()) {
				throw std::invalid_argument("string is too long");
			}
			rhs.resize(length);
			this->read(&rhs[0], length);
			return *this;
		}

		streambuf_type* _buf = nullptr;
	};

	typedef basic_pstream<char> pstream;

	template<class Stream>
	class ipacket_guard {

	private:
		Stream& _stream;

	public:
		inline explicit
		ipacket_guard(Stream& m) noexcept:
		_stream(m)
		{}

		inline
		~ipacket_guard() noexcept {
			this->_stream.skip_packet();
		}

		// disallow copy & move operations
		ipacket_guard() = delete;
		ipacket_guard(const ipacket_guard&) = delete;
		ipacket_guard(ipacket_guard&&) = delete;
		ipacket_guard& operator=(const ipacket_guard&) = delete;
		ipacket_guard& operator=(ipacket_guard&&) = delete;

	};

	template<class Stream>
	class opacket_guard {

	private:
		Stream& _stream;

	public:
		inline explicit
		opacket_guard(Stream& m) noexcept:
		_stream(m)
		{}

		inline
		~opacket_guard() noexcept {
			this->_stream.cancel_packet();
		}

		// disallow copy & move operations
		opacket_guard() = delete;
		opacket_guard(const opacket_guard&) = delete;
		opacket_guard(opacket_guard&&) = delete;
		opacket_guard& operator=(const opacket_guard&) = delete;
		opacket_guard& operator=(opacket_guard&&) = delete;

	};

}

#endif // vim:filetype=cpp
