#ifndef UNISTDX_NET_PSTREAM
#define UNISTDX_NET_PSTREAM

#include <cassert>
#include <stdexcept>

#include <unistdx/base/packetbuf>
#include <unistdx/base/types>
#include <unistdx/bits/no_copy_and_move>
#include <unistdx/config>
#include <unistdx/net/bstream>

namespace sys {

	/**
	\brief
	Packet stream that wraps \link basic_packetbuf\endlink.
	\date 2018-05-24
	\author Ivan Gankevich
	\ingroup stream net
	*/
	template<class Ch, class Tr=std::char_traits<Ch>, class Size=u32>
	class basic_pstream: public basic_bstream<Ch,Tr,Size> {

	private:
		typedef basic_bstream<Ch,Tr,Size> base_type;

	public:
		using typename base_type::char_type;
		using typename base_type::traits_type;
		using typename base_type::size_type;

	public:
		/// Stream buffer type.
		typedef basic_packetbuf<Ch,Tr> streambuf_type;
		/// String type.
		typedef std::basic_string<Ch,Tr> string_type;
		/// Incoming packet guard.
		typedef typename streambuf_type::ipacket_guard ipacket_guard;

	private:
		streambuf_type* _buf2 = nullptr;

	public:

		basic_pstream() = default;

		/// Move-constructor.
		basic_pstream(basic_pstream&& rhs):
		base_type(std::move(rhs)),
		_buf2(rhs._buf2)
		{ rhs._buf2 = nullptr; }

		basic_pstream(const basic_pstream&) = delete;

		basic_pstream&
		operator=(const basic_pstream&) = delete;

		basic_pstream&
		operator=(basic_pstream&&) = delete;

		~basic_pstream() = default;

		/// Construct packet stream with stream buffer \p buf.
		inline explicit
		basic_pstream(streambuf_type* buf):
		base_type(buf)
		{
			this->_buf2 = buf;
		}

		/// Get stream buffer.
		inline streambuf_type*
		rdbuf() noexcept {
			return this->_buf2;
		}

		/// Get stream buffer.
		inline const streambuf_type*
		rdbuf() const noexcept {
			return this->_buf2;
		}

		/// Set stream buffer to \p rhs.
		inline streambuf_type*
		rdbuf(streambuf_type* rhs) {
			streambuf_type* old = this->rdbuf();
			this->base_type::rdbuf(rhs);
			return old;
		}

		/// Start writing a packet.
		inline void
		begin_packet() {
			this->rdbuf()->begin_packet();
		}

		/// Finish writing a packet.
		inline void
		end_packet() {
			this->rdbuf()->end_packet();
		}

		/// Read a packet asynchronously.
		inline bool
		read_packet() {
			return this->rdbuf()->read_packet();
		}

		/// Skip incoming packet.
		inline void
		skip_packet() {
			this->rdbuf()->skip_packet();
		}

		/// Cancel writing outgoing packet.
		inline void
		cancel_packet() {
			this->rdbuf()->cancel_packet();
		}

		/// Append packet payload starting from the beginning.
		inline void
		append_payload(basic_pstream& rhs) {
			// LCOV_EXCL_START
			assert(this->rdbuf());
			assert(rhs.rdbuf());
			// LCOV_EXCL_STOP
			::sys::append_payload(*this->rdbuf(), *rhs.rdbuf());
		}

		/// Append packet payload starting from the current position.
		inline void
		append_payload_cur(basic_pstream& src) {
			// LCOV_EXCL_START
			assert(this->rdbuf());
			assert(src.rdbuf());
			// LCOV_EXCL_STOP
			::sys::append_payload(
				*this->rdbuf(),
				*src.rdbuf(),
				src.rdbuf()->ipayload_offset()
			);
		}

		/// Always returns true.
		inline explicit
		operator bool() const noexcept {
			return true;
		}

		/// Always returns false.
		inline bool
		operator!() const noexcept {
			return !this->operator bool();
		}

	};

	/// Alias to basic_pstream<char>.
	typedef basic_pstream<char> pstream;

	/// Incoming packet guard.
	typedef pstream::ipacket_guard ipacket_guard;

	/**
	\brief Guard object that automatically cancels writing packets without payload.
	\date 2018-05-24
	\author Ivan Gankevich
	*/
	template<class Stream>
	class opacket_guard {

	public:
		/// Output stream type.
		typedef Stream stream_type;

	private:
		Stream& _stream;

	public:

		/// Construct the guard with output stream \p m.
		inline explicit
		opacket_guard(stream_type& m) noexcept:
		_stream(m)
		{}

		/// Destroy the guard cancelling empty packets.
		inline
		~opacket_guard() noexcept {
			this->_stream.cancel_packet();
		}

		UNISTDX_NO_COPY_AND_MOVE(opacket_guard)

	};

}

#endif // vim:filetype=cpp
