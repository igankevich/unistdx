#ifndef UNISTDX_NET_PSTREAM
#define UNISTDX_NET_PSTREAM

#include <cassert>
#include <limits>
#include <stdexcept>

#include <unistdx/base/packetbuf>
#include <unistdx/base/types>
#include <unistdx/config>
#include <unistdx/net/bytes>

#define UNISTDX_MAKE_INOUT_OPERATOR(tp) \
	inline basic_pstream & \
	operator<<(tp rhs) { \
		return this->write(rhs); \
	} \
	inline basic_pstream& \
	operator>>(tp& rhs) { \
		return this->read(rhs); \
	}

namespace sys {

	template<class Ch, class Tr=std::char_traits<Ch>, class Size=u32>
	class basic_pstream {

	public:
		typedef Ch char_type;
		typedef Tr traits_type;
		typedef Size size_type;
		typedef basic_packetbuf<Ch,Tr> streambuf_type;
		typedef std::basic_string<Ch,Tr> string_type;
		typedef typename streambuf_type::ipacket_guard ipacket_guard;

	private:
		typedef std::numeric_limits<Size> size_type_limits;
		typedef std::numeric_limits<typename string_type::size_type>
		    string_size_type_limits;

	private:
		streambuf_type* _buf = nullptr;

	public:

		basic_pstream() = default;

		basic_pstream(basic_pstream&&) = delete;

		basic_pstream(const basic_pstream&) = delete;

		basic_pstream&
		operator=(const basic_pstream&) = delete;

		basic_pstream&
		operator=(basic_pstream&&) = delete;

		~basic_pstream() = default;

		inline explicit
		basic_pstream(streambuf_type* buf):
		_buf(buf) {}

		/// Flush output buffer.
		inline void
		flush() {
			this->_buf->pubflush();
		}

		/// Synchronise input buffer.
		inline void
		sync() {
			this->_buf->pubfill();
		}

		inline streambuf_type*
		rdbuf() {
			return this->_buf;
		}

		inline const streambuf_type*
		rdbuf() const {
			return this->_buf;
		}

		inline streambuf_type*
		rdbuf(streambuf_type* rhs) {
			streambuf_type* old = this->_buf;
			this->_buf = rhs;
			return old;
		}

		inline void
		begin_packet() {
			this->_buf->begin_packet();
		}

		inline void
		end_packet() {
			this->_buf->end_packet();
		}

		inline bool
		read_packet() {
			return this->_buf->read_packet();
		}

		inline void
		skip_packet() {
			this->_buf->skip_packet();
		}

		inline void
		cancel_packet() {
			this->_buf->cancel_packet();
		}

		/// Append packet payload starting from the beginning.
		inline void
		append_payload(basic_pstream& rhs) {
			assert(this->_buf);
			assert(rhs._buf);
			::sys::append_payload(*this->_buf, *rhs._buf);
		}

		/// Append packet payload starting from the current position.
		inline void
		append_payload_cur(basic_pstream& src) {
			assert(this->_buf);
			assert(src._buf);
			::sys::append_payload(
				*this->_buf,
				*src._buf,
				src._buf->ipayload_offset()
			);
		}

		inline explicit
		operator bool() const noexcept {
			return true;
		}

		inline bool
		operator!() const noexcept {
			return !operator bool();
		}

		inline basic_pstream&
		operator<<(bool rhs) {
			return this->write(rhs ? char(1) : char(0));
		}

		UNISTDX_MAKE_INOUT_OPERATOR(char)
		UNISTDX_MAKE_INOUT_OPERATOR(i8)
		UNISTDX_MAKE_INOUT_OPERATOR(i16)
		UNISTDX_MAKE_INOUT_OPERATOR(i32)
		UNISTDX_MAKE_INOUT_OPERATOR(i64)
		UNISTDX_MAKE_INOUT_OPERATOR(u8)
		UNISTDX_MAKE_INOUT_OPERATOR(u16)
		UNISTDX_MAKE_INOUT_OPERATOR(u32)
		UNISTDX_MAKE_INOUT_OPERATOR(u64)
		UNISTDX_MAKE_INOUT_OPERATOR(f32)
		UNISTDX_MAKE_INOUT_OPERATOR(f64)
		#if defined(UNISTDX_HAVE_LONG_DOUBLE)
		UNISTDX_MAKE_INOUT_OPERATOR(f128)
		#endif
		UNISTDX_MAKE_INOUT_OPERATOR(string_type)

		template<class T>
		inline basic_pstream&
		operator<<(const sys::bytes<T,Ch>& rhs) {
			return this->write(rhs.begin(), rhs.size());
		}

		inline basic_pstream&
		operator>>(bool& rhs) {
			char c = 0;
			this->read(c);
			rhs = c == 1;
			return *this;
		}

		template<class T>
		inline basic_pstream&
		operator>>(sys::bytes<T,Ch>& rhs) {
			return this->read(rhs.begin(), rhs.size());
		}

		inline basic_pstream&
		write(const Ch* buf, std::streamsize n) {
			this->_buf->sputn(buf, n);
			return *this;
		}

		inline basic_pstream&
		read(Ch* buf, std::streamsize n) {
			this->_buf->sgetn(buf, n);
			return *this;
		}

	private:

		template<class T>
		inline basic_pstream&
		write(T rhs) {
			#ifndef IGNORE_ISO_IEC559
			static_assert(
				std::is_integral<T>::value or (
					std::is_floating_point<T>::value and
					std::numeric_limits<T>::is_iec559
				),
				"This system does not support ISO IEC 559"
				" floating point representation for either float, double or long double"
				" types, i.e. there is no portable way of"
				" transmitting floating point numbers over the network"
				" without precision loss. If all computers in the network do not"
				" conform to this standard but represent floating point"
				" numbers exactly in the same way, you can ignore this assertion"
				" by defining IGNORE_ISO_IEC559."
			);
			#endif
			bytes<T,Ch> val = rhs;
			val.to_network_format();
			return this->write(val.begin(), val.size());
		}

		inline basic_pstream&
		write(const string_type& rhs) {
			if (rhs.size() > size_type_limits::max()) {
				throw std::invalid_argument("string is too long");
			}
			const size_type length = static_cast<size_type>(rhs.size());
			this->write(length);
			this->_buf->sputn(rhs.c_str(), length);
			return *this;
		}

		template<class T>
		inline basic_pstream&
		read(T& rhs) {
			sys::bytes<T,Ch> val;
			this->read(val.begin(), val.size());
			val.to_host_format();
			rhs = val;
			return *this;
		}

		inline basic_pstream&
		read(string_type& rhs) {
			size_type length = 0;
			this->read(length);
			if (length > string_size_type_limits::max()) {
				throw std::invalid_argument("string is too long");
			}
			rhs.resize(length);
			this->read(&rhs[0], length);
			return *this;
		}

	};

	typedef basic_pstream<char> pstream;
	typedef pstream::ipacket_guard ipacket_guard;

	template<class Stream>
	class opacket_guard {

	private:
		Stream& _stream;

	public:
		inline explicit
		opacket_guard(Stream& m) noexcept:
		_stream(m)
		{}

		inline
		~opacket_guard() noexcept {
			this->_stream.cancel_packet();
		}

		// disallow copy & move operations
		opacket_guard() = delete;

		opacket_guard(const opacket_guard&) = delete;

		opacket_guard(opacket_guard&&) = delete;

		opacket_guard&
		operator=(const opacket_guard&) = delete;

		opacket_guard&
		operator=(opacket_guard&&) = delete;

	};

}

#undef UNISTDX_MAKE_INOUT_OPERATOR

#endif // vim:filetype=cpp
