#ifndef UNISTDX_NET_SOCKET
#define UNISTDX_NET_SOCKET

#include <fcntl.h>
#include <unistd.h>

#include <chrono>

#include <unistdx/bits/socket>
#include <unistdx/config>
#include <unistdx/io/fildes>
#include <unistdx/net/endpoint>

namespace sys {

	/**
	\brief Message header type for sending and receiving low-level socket messages.
	\see \man{sendmsg,2}, \man{recvmsg,2}
	*/
	typedef struct ::msghdr message_header;

	/**
	\brief
	Message header type for sending and receiving ancillary data through socket.
	\see \man{sendmsg,2}, \man{recvmsg,2}, \man{cmsg,3}
	*/
	typedef struct ::cmsghdr cmessage_header;

	#if defined(UNISTDX_HAVE_SCM_CREDENTIALS)
	/// Alias to \c ucred system type.
	typedef struct ::ucred user_credentials;
	#endif

	/// Alias to \c iovec system type.
	typedef struct ::iovec io_vector;

	/// Socket types.
	enum class socket_type {
		stream = SOCK_STREAM,
		datagram = SOCK_DGRAM,
		raw = SOCK_RAW
	};

	/**
	\brief Socket wrapper.
	\date 2018-05-24
	\author Ivan Gankevich
	\ingroup net
	\details
	\arg Socket is a file descriptor which is used for communication.
	\arg Usually, sockets are used for network communication.
	*/
	class socket: public fildes {

	private:
		typedef int opt_type;

	public:
		#if defined(UNISTDX_HAVE_TCP_USER_TIMEOUT)
		/// Clock type used in this class.
		typedef std::chrono::system_clock clock_type;
		/// Duration type.
		typedef clock_type::duration duration;
		#endif
		/// Protocol number type.
		typedef int protocol_type;

		/// Socket options.
		enum option : opt_type {
			reuse_addr = SO_REUSEADDR,
			keep_alive = SO_KEEPALIVE,
			/**
			\brief Enables sending and receiving UID, GID and PID
			of the process via unix domain socket.
			\see \man{unix,7}
			*/
			pass_credentials = SO_PASSCRED,
		};

		/// Socket shutdown options.
		enum shutdown_how {
			shut_read = SHUT_RD,
			shut_write = SHUT_WR,
			shut_read_write = SHUT_RDWR
		};

		/**
		Default socket flags. The socket is non-blocking and automatically
		closed on child process execution.
		*/
		static const flag_type default_flags =
			UNISTDX_SOCK_NONBLOCK | UNISTDX_SOCK_CLOEXEC;

		socket() = default;

		socket(const socket&) = delete;

		socket&
		operator=(const socket&) = delete;

		/// Move-constructor.
		inline explicit
		socket(socket&& rhs) noexcept:
		sys::fildes(std::move(rhs)) {}

		/// Construct the socket from file descriptor rhs.
		inline explicit
		socket(fildes&& rhs) noexcept:
		sys::fildes(std::move(rhs)) {}

		/**
		\brief Construct the socket and bind on \p bind_addr and listen.
		\throws bad_call
		*/
		explicit
		socket(const endpoint& bind_addr);

		/**
		\brief
		Construct the socket, bind on \p bind_addr and connect
		to a process listening on \p conn_addr.
		\throws bad_call
		*/
		socket(const endpoint& bind_addr, const endpoint& conn_addr);

		/**
		\brief
		Construct the socket with protocol family \p family, type \p type
		and protocol \p proto.
		\throws bad_call
		*/
		socket(
			family_type family,
			socket_type type=socket_type::stream,
			protocol_type proto=0
		);

		/// Close the socket.
		inline
		~socket() {
			this->close();
		}

		/// Move-assignment.
		inline socket&
		operator=(socket&& rhs) {
			sys::fildes::operator=(std::move(static_cast<sys::fildes&&>(rhs)));
			return *this;
		}

		/**
		\brief Bind on socket address \p e.
		\throws bad_call
		*/
		void
		bind(const endpoint& e);

		/**
		\brief Connect to socket address \p e.
		\throws bad_call if system error occurs, except
		\c std::errc::operation_in_progress
		\see std::errc
		*/
		void
		connect(const endpoint& e);

		/**
		\brief Listen on previously binded socket address.
		\throws bad_call
		*/
		void
		listen();

		/**
		\brief Accept socket connection.
		\date 2018-05-24
		\author Ivan Gankevich
		\throws bad_call
		\param[out] sock socket that initiated a connection (client)
		\param[out] addr sockt address of the client
		*/
		void
		accept(socket& sock, endpoint& addr);

		/**
		\brief Shutdown communication on the socket, but do not close it.
		\throws bad_call if system error occurs, except
		\c std::errc::not_connected and \c std::errc::not_supported
		\see std::errc
		*/
		void
		shutdown(shutdown_how how);

		/**
		\brief Close the socket.
		\throws bad_call
		*/
		void
		close();

		/**
		\brief Activate socket option.
		\throws bad_call
		*/
		void
		setopt(option opt);

		#if defined(UNISTDX_HAVE_TCP_USER_TIMEOUT)
		/**
		\brief Set TCP user timeout option (see \rfc{5482}).
		\throws bad_call
		*/
		void
		set_user_timeout(const duration& d);
		#endif

		/**
		\brief \copybrief name
		\throws bad_call
		\details
		The same as \link name\endlink, but does not throw.
		*/
		inline endpoint
		bind_addr() const noexcept {
			endpoint addr;
			socklen_type len = sizeof(endpoint);
			::getsockname(this->_fd, addr.sockaddr(), &len);
			return addr;
		}

		/**
		\brief Get bound socket address.
		\throws bad_call
		*/
		inline endpoint
		name() const {
			endpoint addr;
			socklen_type len = sizeof(endpoint);
			UNISTDX_CHECK(::getsockname(this->_fd, addr.sockaddr(), &len));
			return addr;
		}

		/**
		\brief Get address of the client, connected to the socket.
		\throws bad_call
		*/
		inline endpoint
		peer_name() const {
			endpoint addr;
			socklen_type len = sizeof(endpoint);
			UNISTDX_CHECK(::getpeername(this->_fd, addr.sockaddr(), &len));
			return addr;
		}

		/**
		\brief Send low-level message \p hdr through the socket.
		\throws bad_call if system error occurs,
		except \c std::errc::resource_unavailable_try_again
		and \c std::errc::operation_in_progress
		\see std::errc
		*/
		inline ssize_t
		send(const message_header& hdr, int flags=0) const {
			ssize_t ret = ::sendmsg(this->_fd, &hdr, flags);
			if (ret == -1 && errno != EAGAIN && errno != EINPROGRESS) {
				UNISTDX_THROW_BAD_CALL();
			}
			return ret;
		}

		/**
		\brief Receive low-level message \p hdr over the socket.
		\throws bad_call if system error occurs,
		except \c std::errc::resource_unavailable_try_again
		and \c std::errc::operation_in_progress
		\see std::errc
		*/
		inline ssize_t
		receive(message_header& hdr, int flags=0) const {
			ssize_t ret = ::recvmsg(this->_fd, &hdr, flags);
			if (ret == -1 && errno != EAGAIN && errno != EINPROGRESS) {
				UNISTDX_THROW_BAD_CALL();
			}
			return ret;
		}

		/**
		\brief
		Read \p n bytes from the socket and store them in buffer
		pointed by \p buf.
		\throws bad_call if system error occurs,
		except \c std::errc::resource_unavailable_try_again
		and \c std::errc::operation_in_progress
		\see std::errc
		*/
		inline ssize_t
		receive(void* buf, size_t n, int flags=0) const {
			ssize_t ret = ::recv(this->_fd, buf, n, flags);
			if (ret == -1 && errno != EAGAIN && errno != EINPROGRESS) {
				UNISTDX_THROW_BAD_CALL();
			}
			return ret;
		}

		/**
		\brief
		Write \p n bytes from buffer pointed by \p buf to the socket.
		\throws bad_call if system error occurs,
		except \c std::errc::resource_unavailable_try_again
		and \c std::errc::operation_in_progress
		\see std::errc
		*/
		inline ssize_t
		send(const void* buf, size_t n, int flags=0) const noexcept {
			ssize_t ret = ::send(this->_fd, buf, n, flags);
			if (ret == -1 && errno != EAGAIN && errno != EINPROGRESS) {
				UNISTDX_THROW_BAD_CALL();
			}
			return ret;
		}

		#if defined(UNISTDX_HAVE_SO_PEERCRED)
		/**
		\brief
		Get UID, GID and PID of the process, that connected to this socket (client).
		\throws bad_call
		\note The method works only for unix domain sockets.
		*/
		user_credentials
		credentials() const;
		#endif

		#if defined(UNISTDX_HAVE_SCM_RIGHTS)
		/**
		\brief
		Send an array of \p n file descriptors pointed by \p data.
		\throws bad_call
		\note The method works only for unix domain sockets.
		*/
		void
		send_fds(const fd_type* data, size_t n);

		/**
		\brief
		Receive an array of \p n file descriptors pointed by \p data.
		\throws bad_call
		\note The method works only for unix domain sockets.
		*/
		void
		receive_fds(fd_type* data, size_t n);
		#endif

		friend std::ostream&
		operator<<(std::ostream& out, const socket& rhs);

	protected:

		/// Construct the socket with bare file descriptor.
		inline explicit
		socket(fd_type sock) noexcept:
		sys::fildes(sock) {}

	private:
		void
		create_socket_if_necessary(const endpoint& e);

		int
		error() const noexcept;

		inline std::string
		status_message() const noexcept {
			return this->error() == 0
			       ? "ok"
				   : std::make_error_code(std::errc(errno)).message();
		}

	};

	/// Print socket file descriptor and status.
	std::ostream&
	operator<<(std::ostream& out, const socket& rhs);

	#if defined(UNISTDX_HAVE_SCM_CREDENTIALS)
	/**
	\brief
	Manually send process UID, GID, PID as opaque array pointed by \p data.
	\note On Linux \link socket::credentials\endlink returns credentials
	without manually sending and receiving this message provided that
	\link socket::pass_credentials\endlink socket option is set.
	\ingroup net
	*/
	void
	send_credentials(socket& sock, const void* data, size_t n);

	/**
	\brief
	Manually receive process UID, GID, PID as opaque array pointed by \p data.
	\note On Linux \link socket::credentials\endlink returns credentials
	without manually sending and receiving this message provided that
	\link socket::pass_credentials\endlink socket option is set.
	\ingroup net
	*/
	void
	receive_credentials(socket& sock, message_header& h, void* data, size_t n);
	#endif

	/**
	\brief
	Stream buffer traits for \link socket\endlink.
	\date 2018-05-24
	\author Ivan Gankevich
	\ingroup traits net
	*/
	template<>
	struct streambuf_traits<socket> {

		/// Character type.
		typedef void char_type;

		/**
		Write \p n bytes from array pointed by \p s to socket \p sink.
		*/
		inline static std::streamsize
		write(socket& sink, const char_type* s, std::streamsize n) {
			return sink.send(s, n);
		}

		/**
		Read \p n bytes to array pointed by \p s from socket \p src.
		*/
		inline static std::streamsize
		read(socket& src, char_type* s, std::streamsize n) {
			return src.receive(s, n);
		}

	};

}

#endif // vim:filetype=cpp
