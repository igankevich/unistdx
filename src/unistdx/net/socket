/*
UNISTDX — C++ library for Linux system calls.
© 2017, 2018, 2019, 2020 Ivan Gankevich

This file is part of UNISTDX.

This is free and unencumbered software released into the public domain.

Anyone is free to copy, modify, publish, use, compile, sell, or
distribute this software, either in source code form or as a compiled
binary, for any purpose, commercial or non-commercial, and by any
means.

In jurisdictions that recognize copyright laws, the author or authors
of this software dedicate any and all copyright interest in the
software to the public domain. We make this dedication for the benefit
of the public at large and to the detriment of our heirs and
successors. We intend this dedication to be an overt act of
relinquishment in perpetuity of all present and future rights to this
software under copyright law.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
OTHER DEALINGS IN THE SOFTWARE.

For more information, please refer to <http://unlicense.org/>
*/

#ifndef UNISTDX_NET_SOCKET
#define UNISTDX_NET_SOCKET

#include <fcntl.h>
#include <unistd.h>

#include <chrono>

#include <unistdx/bits/socket>
#include <unistdx/config>
#include <unistdx/io/fildes>
#include <unistdx/net/socket_address>

namespace sys {

    /**
    \brief Message header type for sending and receiving low-level socket messages.
    \see \man{sendmsg,2}, \man{recvmsg,2}
    */
    typedef struct ::msghdr message_header;

    /**
    \brief
    Message header type for sending and receiving ancillary data through socket.
    \see \man{sendmsg,2}, \man{recvmsg,2}, \man{cmsg,3}
    */
    typedef struct ::cmsghdr cmessage_header;

    #if defined(UNISTDX_HAVE_SCM_CREDENTIALS) || \
        defined(UNISTDX_HAVE_SO_PEERCRED)
    /// Alias to \c ucred system type.
    typedef struct ::ucred user_credentials;
    #endif

    /// Alias to \c iovec system type.
    typedef struct ::iovec io_vector;

    /// Socket types.
    enum class socket_type {
        stream = SOCK_STREAM,
        datagram = SOCK_DGRAM,
        raw = SOCK_RAW
    };

    /// Socket shutdown options.
    enum class shutdown_flag: int {
        read = SHUT_RD,
        write = SHUT_WR,
        read_write = SHUT_RDWR
    };

    template <>
    struct is_flag<shutdown_flag>: public std::true_type {};


    /**
    \brief Socket wrapper.
    \date 2018-05-24
    \ingroup net
    \details
    \arg Socket is a file descriptor which is used for communication.
    \arg Usually, sockets are used for network communication.
    \arg The socket is non-blocking and automatically closed on child
    process execution.
    */
    class socket: public fildes {

    private:
        typedef int opt_type;

    public:
        #if defined(UNISTDX_HAVE_TCP_USER_TIMEOUT)
        /// Clock type used in this class.
        typedef std::chrono::system_clock clock_type;
        /// Duration type.
        typedef clock_type::duration duration;
        #endif
        /// Protocol number type.
        typedef int protocol_type;

        /// Socket options.
        enum option : opt_type {
            reuse_addr = SO_REUSEADDR,
            keep_alive = SO_KEEPALIVE,
            /**
            \brief Enables sending and receiving UID, GID and PID
            of the process via unix domain socket.
            \see \man{unix,7}
            */
            pass_credentials = SO_PASSCRED,
        };

        socket() = default;

        inline
        socket(const socket& rhs):
        fildes(rhs) {}

        inline socket&
        operator=(const socket& rhs) {
            this->fildes::operator=(rhs);
            return *this;
        }

        /// Move-constructor.
        inline explicit
        socket(socket&& rhs) noexcept:
        sys::fildes(std::move(rhs)) {}

        /// Construct the socket from file descriptor rhs.
        inline explicit
        socket(fildes&& rhs) noexcept:
        sys::fildes(std::move(rhs)) {}

        /**
        \brief Construct the socket and bind on \p bind_addr and listen.
        \throws bad_call
        \see \man{socket,2}
        */
        explicit
        socket(const socket_address& bind_addr);

        /**
        \brief
        Construct the socket, bind on \p bind_addr and connect
        to a process listening on \p conn_addr.
        \throws bad_call
        \see \man{socket,2}
        */
        socket(const socket_address& bind_addr, const socket_address& conn_addr);

        /**
        \brief
        Construct the socket with protocol family \p family, type \p type
        and protocol \p proto.
        \throws bad_call
        \see \man{socket,2}
        */
        socket(
            family_type family,
            socket_type type=socket_type::stream,
            protocol_type proto=0
        );

        /// Close the socket.
        inline
        ~socket() {
            this->close();
        }

        /// Move-assignment.
        inline socket&
        operator=(socket&& rhs) {
            this->swap(rhs);
            return *this;
        }

        /**
        \brief Bind on socket address \p e.
        \throws bad_call
        \see \man{bind,2}
        */
        void
        bind(const socket_address& e);

        /**
        \brief Connect to socket address \p e.
        \throws bad_call if system error occurs, except
        \c std::errc::operation_in_progress
        \see \man{connect,2}
        \see std::errc
        */
        void
        connect(const socket_address& e);

        /**
        \brief Listen on previously binded socket address.
        \throws bad_call
        \see \man{listen,2}
        */
        void
        listen();

        /**
        \brief Accept socket connection.
        \date 2018-05-24
        \throws bad_call
        \see \man{accept4,2}
        \param[out] client_socket socket that initiated a connection (client)
        \param[out] client_address socket address of the client
        \return true if the connection was accepted and more connections might be
        accepted, false if there are no more connections to be accepted
        */
        bool
        accept(socket& client_socket, socket_address& client_address);

        /**
        \brief Shutdown communication on the socket, but do not close it.
        \throws bad_call if system error occurs, except
        \c std::errc::not_connected and \c std::errc::not_supported
        \see \man{shutdown,2}
        \see std::errc
        */
        void
        shutdown(shutdown_flag how);

        /**
        \brief Shutdown and close the socket.
        \throws bad_call
        \see \man{shutdown,2}
        \see \man{close,2}
        */
        void
        close();

        /**
        \brief Activate socket option.
        \throws bad_call
        \see \man{setsockopt,2}
        */
        void
        setopt(option opt);

        #if defined(UNISTDX_HAVE_TCP_USER_TIMEOUT)
        /**
        \brief Set TCP user timeout option (see \rfc{5482}).
        \throws bad_call
        \see \man{setsockopt,2}
        \see \man{tcp,7}
        */
        void
        set_user_timeout(const duration& d);
        #endif

        /**
        \brief \copybrief name
        \see \man{getsockname,2}
        \details
        The same as \link name \endlink, but does not throw.
        */
        inline socket_address
        bind_addr() const noexcept {
            socket_address addr;
            socklen_type len = sizeof(socket_address);
            ::getsockname(this->_fd, addr.sockaddr(), &len);
            return addr;
        }

        /**
        \brief Get bound socket address.
        \throws bad_call
        \see \man{getsockname,2}
        */
        inline socket_address
        name() const {
            socket_address addr;
            socklen_type len = sizeof(socket_address);
            UNISTDX_CHECK(::getsockname(this->_fd, addr.sockaddr(), &len));
            return addr;
        }

        /**
        \brief Get address of the client, connected to the socket.
        \throws bad_call
        \see \man{getpeername,2}
        */
        inline socket_address
        peer_name() const {
            socket_address addr;
            socklen_type len = sizeof(socket_address);
            UNISTDX_CHECK(::getpeername(this->_fd, addr.sockaddr(), &len));
            return addr;
        }

        /**
        \brief Send low-level message \p hdr through the socket.
        \throws_bad_call_non_blocking
        \see \man{sendmsg,2}
        */
        inline ssize_t
        send(const message_header& hdr, int flags=0) const {
            ssize_t ret = ::sendmsg(this->_fd, &hdr, flags);
            UNISTDX_CHECK_IO(ret);
            return ret;
        }

        /**
        \brief Receive low-level message \p hdr over the socket.
        \throws_bad_call_non_blocking
        \see \man{recvmsg,2}
        */
        inline ssize_t
        receive(message_header& hdr, int flags=0) const {
            ssize_t ret = ::recvmsg(this->_fd, &hdr, flags);
            UNISTDX_CHECK_IO(ret);
            return ret;
        }

        /**
        \brief
        Read \p n bytes from the socket and store them in buffer
        pointed by \p buf.
        \throws_bad_call_non_blocking
        \see \man{recv,2}
        */
        inline ssize_t
        receive(void* buf, size_t n, int flags=0) const {
            ssize_t ret = ::recv(this->_fd, buf, n, flags);
            UNISTDX_CHECK_IO(ret);
            return ret;
        }

        /**
        \brief
        Write \p n bytes from buffer pointed by \p buf to the socket.
        \throws_bad_call_non_blocking
        \see \man{send,2}
        */
        inline ssize_t
        send(const void* buf, size_t n, int flags=0) const {
            ssize_t ret = ::send(this->_fd, buf, n, flags);
            UNISTDX_CHECK_IO(ret);
            return ret;
        }

        #if defined(UNISTDX_HAVE_SO_PEERCRED)
        /**
        \brief
        Get UID, GID and PID of the process, that is connected
        to this socket (client).
        \throws bad_call
        \see \man{getsockopt,2}
        \note The method works only for unix domain sockets.
        */
        user_credentials
        credentials() const;
        #endif

        #if defined(UNISTDX_HAVE_SCM_RIGHTS)
        /**
        \brief
        Send an array of \p n file descriptors pointed by \p data.
        \throws bad_call
        \see \man{cmsg,3}
        \see \man{unix,7}
        \note The method works only for unix domain sockets.
        */
        void
        send_fds(const fd_type* data, size_t n);

        /**
        \brief
        Receive an array of \p n file descriptors pointed by \p data.
        \throws bad_call
        \see \man{cmsg,3}
        \see \man{unix,7}
        \note The method works only for unix domain sockets.
        */
        void
        receive_fds(fd_type* data, size_t n);
        #endif

        /// Swap with \p rhs.
        inline void
        swap(socket& rhs) {
            this->fildes::swap(static_cast<fildes&>(rhs));
        }

        friend std::ostream&
        operator<<(std::ostream& out, const socket& rhs);

    protected:

        /// Construct the socket with bare file descriptor.
        inline explicit
        socket(fd_type sock) noexcept:
        sys::fildes(sock) {}

    private:
        void
        create_socket_if_necessary(const socket_address& e);

        int
        error() const noexcept;

        inline std::string
        status_message() const noexcept {
            return this->error() == 0
                   ? "ok"
                   : std::make_error_code(std::errc(errno)).message();
        }

    };

    /// Overload of \link std::swap \endlink for \link socket \endlink.
    inline void
    swap(socket& lhs, socket& rhs) {
        lhs.swap(rhs);
    }

    /// Print socket file descriptor and status.
    std::ostream&
    operator<<(std::ostream& out, const socket& rhs);

    /**
    \brief
    Stream buffer traits for \link socket \endlink.
    \date 2018-05-24
    \ingroup traits net
    */
    template<>
    struct streambuf_traits<socket> {

        /// Character type.
        typedef void char_type;

        /**
        Write \p n bytes from array pointed by \p s to socket \p sink.
        */
        inline static std::streamsize
        write(socket& sink, const char_type* s, std::streamsize n) {
            return sink.send(s, n);
        }

        /**
        Read \p n bytes to array pointed by \p s from socket \p src.
        */
        inline static std::streamsize
        read(socket& src, char_type* s, std::streamsize n) {
            return src.receive(s, n);
        }

    };

}

#endif // vim:filetype=cpp
