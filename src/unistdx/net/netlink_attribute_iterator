#ifndef UNISTDX_NET_NETLINK_ATTRIBUTE_ITERATOR
#define UNISTDX_NET_NETLINK_ATTRIBUTE_ITERATOR

#include <cassert>
#include <iterator>

namespace sys {

    /**
    \brief Iterator for netlink message attributes.
    \date 2018-05-25
    \author Ivan Gankevich
    \ingroup iter net
    */
    template <class T>
    class netlink_attribute_iterator:
        public std::iterator<std::input_iterator_tag, T> {

    private:
        typedef T attr_type;
        typedef typename std::iterator<std::input_iterator_tag, T> base_type;

    public:
        using typename base_type::iterator_category;
        using typename base_type::value_type;
        using typename base_type::pointer;
        using typename base_type::reference;
        using typename base_type::difference_type;

    private:
        typedef const value_type* const_pointer;
        typedef const value_type& const_reference;

    private:
        attr_type* _attr = nullptr;
        int _len = 0;

    public:

        /// Construct netlink iterator from message pointer \p rhs.
        inline explicit
        netlink_attribute_iterator(attr_type* rhs, int len):
        _attr(rhs),
        _len(len) {
            // LCOV_EXCL_START
            assert(this->_attr);
            assert(this->_len >= 0);
            // LCOV_EXCL_STOP
        }

        netlink_attribute_iterator() = default;

        inline
        ~netlink_attribute_iterator() = default;

        /// Copy-constructor.
        netlink_attribute_iterator(const netlink_attribute_iterator&) = default;

        /// Assignment.
        inline netlink_attribute_iterator&
        operator=(const netlink_attribute_iterator&) noexcept = default;

        /// Compare pointers.
        inline constexpr bool
        operator==(const netlink_attribute_iterator& rhs) const noexcept {
            return this->_attr == rhs._attr;
        }

        /// Compare pointers.
        inline constexpr bool
        operator!=(const netlink_attribute_iterator& rhs) const noexcept {
            return !this->operator==(rhs);
        }

        /// Dereference.
        inline reference
        operator*() noexcept {
            return *this->_attr;
        }

        /// Dereference.
        inline constexpr const_reference
        operator*() const noexcept {
            return *this->_attr;
        }

        /// Access object by pointer.
        inline pointer
        operator->() noexcept {
            return this->_attr;
        }

        /// Access object by pointer.
        inline constexpr const_pointer
        operator->() const noexcept {
            return this->_attr;
        }

        /// Increment.
        inline netlink_attribute_iterator&
        operator++() noexcept {
            this->do_next();
            return *this;
        }

        /// Post-increment.
        inline netlink_attribute_iterator
        operator++(int) noexcept {
            netlink_attribute_iterator tmp(*this);
            this->do_next();
            return tmp;
        }

    private:

        inline bool
        ok() const noexcept {
            return this->_attr->ok(this->_len);
        }

        inline bool
        done() const noexcept {
            return this->_attr->done();
        }

        inline value_type*
        next() noexcept {
            return static_cast<value_type*>(this->_attr->next(this->_len));
        }

        inline void
        do_next() noexcept {
            assert(this->_attr); // LCOV_EXCL_LINE
            this->_attr = this->next();
            if (!this->ok()) {
                this->_attr = nullptr;
            }
        }

    };

}

#endif // vim:filetype=cpp
