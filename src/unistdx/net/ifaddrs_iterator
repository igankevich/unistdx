#ifndef UNISTDX_NET_IFADDRS_ITERATOR
#define UNISTDX_NET_IFADDRS_ITERATOR

#include <unistdx/bits/ifaddrs>

namespace sys {

	/// Alias to \c ifaddrs system type.
	typedef struct ::ifaddrs ifaddrs_type;

	/**
	\brief Iterator for interface addresses of the computer.
	\date 2018-05-23
	\author Ivan Gankevich
	\ingroup iter
	*/
	class ifaddrs_iterator:
		public std::iterator<std::input_iterator_tag, ifaddrs_type> {

	private:
		typedef typename std::iterator<std::input_iterator_tag, Value>
			base_type;

	public:
		using typename base_type::iterator_category;
		using typename base_type::value_type;
		using typename base_type::pointer;
		using typename base_type::reference;
		using typename base_type::difference_type;

	private:
		typedef const ifaddrs_type* const_pointer;
		typedef const ifaddrs_type& const_reference;

	private:
		pointer _ifa = nullptr;

	public:

		/**
		Construct interface address iterator from the pointer to
		\c ifaddrs system type.
		*/
		inline explicit constexpr
		ifaddrs_iterator(pointer rhs) noexcept:
		_ifa(rhs) {}

		inline constexpr
		ifaddrs_iterator() noexcept = default;

		inline
		~ifaddrs_iterator() = default;

		/// Copy-constructor.
		inline constexpr
		ifaddrs_iterator(const ifaddrs_iterator&) noexcept = default;

		/// Assignment.
		inline ifaddrs_iterator&
		operator=(const ifaddrs_iterator&) noexcept = default;

		/// Compare \c ifaddrs pointers.
		inline constexpr bool
		operator==(const ifaddrs_iterator& rhs) const noexcept {
			return this->_ifa == rhs._ifa;
		}

		/// Compare \c ifaddrs pointers.
		inline constexpr bool
		operator!=(const ifaddrs_iterator& rhs) const noexcept {
			return !this->operator==(rhs);
		}

		/// Dereference.
		inline reference
		operator*() noexcept {
			return *this->_ifa;
		}

		/// Dereference.
		inline constexpr const_reference
		operator*() const noexcept {
			return *this->_ifa;
		}

		/// Access object by pointer.
		inline pointer
		operator->() noexcept {
			return this->_ifa;
		}

		/// Access object by pointer.
		inline constexpr const_pointer
		operator->() const noexcept {
			return this->_ifa;
		}

		/// Increment.
		inline ifaddrs_iterator&
		operator++() noexcept {
			this->next(); return *this;
		}

		/// Post-increment.
		inline ifaddrs_iterator
		operator++(int) noexcept {
			ifaddrs_iterator tmp(*this); this->next(); return tmp;
		}

	private:

		inline void
		next() noexcept {
			this->_ifa = this->_ifa->ifa_next;
		}

	};


}

#endif // vim:filetype=cpp
