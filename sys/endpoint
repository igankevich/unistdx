#ifndef SYS_ENDPOINT_HH
#define SYS_ENDPOINT_HH

#include <netinet/in.h>
#include <sys/types.h>

#include <bitset>
#include <functional>
#include <istream>
#include <limits>
#include <ostream>
#include <sstream>
#include <tuple>

#include <stdx/ios.hh>
#include <stdx/uint128.hh>

#include "bits/bit_count.hh"
#include "bits/endpoint_parse.hh"
#include "network_format.hh"
#include <sys/check>
#include <sys/packetstream.hh>


namespace sys {

	typedef struct ::sockaddr sa_type;
	typedef struct ::sockaddr_in sockinet4_type;
	typedef struct ::sockaddr_in6 sockinet6_type;
	typedef struct ::in_addr inet4_type;
	typedef struct ::in6_addr inet6_type;
	typedef ::socklen_t socklen_type;
	typedef bits::family_type family_type;
	typedef bits::legacy_family_type sa_family_type;
	typedef ::in_addr_t addr4_type;
	typedef std::uint128_t addr6_type;
	typedef ::in_port_t port_type;
	typedef unsigned int prefix_type;

	template<class Address>
	struct ipaddr_traits;

	union ipv4_addr {

		typedef uint8_t oct_type;
		typedef addr4_type rep_type;

		inline constexpr
		ipv4_addr() noexcept:
		addr(0) {}

		inline constexpr explicit
		ipv4_addr(addr4_type rhs) noexcept:
		addr(rhs) {}

		inline constexpr
		ipv4_addr(const ipv4_addr &rhs) noexcept:
		addr(rhs.addr) {}

		inline constexpr explicit
		ipv4_addr(const inet4_type& rhs) noexcept:
		addr(rhs.s_addr) {}

		inline constexpr
		ipv4_addr(oct_type o1, oct_type o2, oct_type o3, oct_type o4):
			addr(from_octets(o1, o2, o3, o4)) {}

		inline
		ipv4_addr(const sa_type &rhs) noexcept;

		friend std::ostream&
		operator<<(std::ostream& out, ipv4_addr rhs);

		friend std::istream&
		operator>>(std::istream& in, ipv4_addr& rhs);

		inline friend packetstream&
		operator<<(packetstream& out, const ipv4_addr& rhs) {
			return out << rhs._bytes;
		}

		inline friend packetstream&
		operator>>(packetstream& in, ipv4_addr& rhs) {
			return in >> rhs._bytes;
		}

		inline constexpr addr4_type
		rep() const {
			return this->addr;
		}

		inline constexpr
		operator const inet4_type&() const noexcept {
			return this->inaddr;
		}

		inline constexpr bool
		operator<(const ipv4_addr& rhs) const noexcept {
			return this->addr < rhs.addr;
		}

		inline constexpr bool
		operator==(ipv4_addr rhs) const noexcept {
			return this->addr == rhs.addr;
		}

		inline constexpr bool
		operator!=(ipv4_addr rhs) const noexcept {
			return this->addr != rhs.addr;
		}

		inline constexpr explicit
		operator bool() const noexcept {
			return this->addr != 0;
		}

		inline constexpr bool
		operator!() const noexcept {
			return this->addr == 0;
		}

		inline constexpr oct_type
		operator[](size_t i) const noexcept {
			return this->_bytes[i];
		}

		inline prefix_type
		to_prefix() const noexcept {
			return bits::bit_count(addr);
		}

		inline static ipv4_addr
		    from_prefix(prefix_type prefix) noexcept;

	private:

		template<class Q>
		inline constexpr static
		Q
		position_helper(Q a, Q netmask) noexcept {
			return a - (a & netmask);
		}

	public:

		inline constexpr addr4_type
		position(ipv4_addr netmask) const noexcept {
			return position_helper(
				to_host_format(rep()),
				to_host_format(netmask.rep())
			);
		}

	private:

		inline constexpr static addr4_type
		from_octets(oct_type o1, oct_type o2, oct_type o3, oct_type o4) {
			return (
				((o1 << 0)  & UINT32_C(0xff)) |
				((o2 << 8)  & UINT32_C(0xff00)) |
				((o3 << 16) & UINT32_C(0xff0000)) |
				((o4 << 24) & UINT32_C(0xff000000)));
		}

		static const size_t nbits =
			sizeof(addr4_type) * std::numeric_limits<unsigned char>::digits;

		addr4_type addr;
		inet4_type inaddr;
		bytes<addr4_type> _bytes;

		static_assert(sizeof(addr) == sizeof(inaddr), "bad ipv4_addr size");
		static_assert(sizeof(addr) == sizeof(_bytes), "bad ipv4_addr size");
	};

	std::ostream&
	operator<<(std::ostream& out, ipv4_addr rhs);

	std::istream&
	operator>>(std::istream& in, ipv4_addr& rhs);

	inline constexpr ipv4_addr
	operator"" _ipv4(const char* arr, std::size_t n) noexcept {
		return ipv4_addr(bits::do_parse_ipv4_addr<addr4_type>(arr, arr+n));
	}

	template<>
	struct ipaddr_traits<ipv4_addr> {

		typedef ipv4_addr::oct_type oct_type;

		static constexpr const oct_type loopback_first_octet = 127;
		static constexpr const sa_family_type family = AF_INET;

		inline static constexpr ipv4_addr
		localhost() noexcept {
			return ipv4_addr {127,0,0,1};
		}

		inline static constexpr ipv4_addr
		loopback_mask() noexcept {
			return ipv4_addr {255,0,0,0};
		}

		inline static constexpr ipv4_addr
		widearea_mask() noexcept {
			return ipv4_addr {255,255,255,255};
		}

	};

	union ipv6_addr {

		typedef uint16_t hex_type;

		typedef addr6_type rep_type;

		inline constexpr
		ipv6_addr() noexcept:
		inaddr {} {}

		inline constexpr
		ipv6_addr(const ipv6_addr &rhs) noexcept:
		inaddr(rhs.inaddr) {}

		inline constexpr explicit
		ipv6_addr(addr6_type rhs) noexcept:
		addr(rhs) {}

		inline constexpr explicit
		ipv6_addr(const inet6_type& rhs) noexcept:
		inaddr(rhs) {}

		inline constexpr
		ipv6_addr(
			hex_type h1,
			hex_type h2,
			hex_type h3,
			hex_type h4,
			hex_type h5,
			hex_type h6,
			hex_type h7,
			hex_type h8
		):
			addr(from_hextets(h1, h2, h3, h4, h5, h6, h7, h8)) {}

		inline constexpr
		operator const inet6_type&() const {
			return this->inaddr;
		}

		inline constexpr const inet6_type&
		rep() const noexcept {
			return this->inaddr;
		}

		inline constexpr bool
		operator<(const ipv6_addr& rhs) const {
			return this->addr < rhs.addr;
		}

		inline constexpr bool
		operator==(const ipv6_addr& rhs) const {
			return this->addr == rhs.addr;
		}

		inline constexpr explicit
		operator bool() const {
			return this->addr != 0;
		}

		inline constexpr bool
		operator!() const {
			return !operator bool();
		}

		friend std::ostream&
		operator<<(std::ostream& out, const ipv6_addr& rhs);

		friend std::istream&
		operator>>(std::istream& in, ipv6_addr& rhs);

		inline friend packetstream&
		operator<<(packetstream& out, const ipv6_addr& rhs) {
			return out << rhs._bytes;
		}

		inline friend packetstream&
		operator>>(packetstream& in, ipv6_addr& rhs) {
			return in >> rhs._bytes;
		}

	private:
		inline constexpr const hex_type*
		begin() const noexcept {
			return this->_hextets;
		}

		inline constexpr const hex_type*
		end() const noexcept {
			return this->_hextets + num_fields();
		}

		inline hex_type*
		begin() noexcept {
			return this->_hextets;
		}
		inline hex_type*
		end() noexcept {
			return this->_hextets + num_fields();
		}

		static constexpr int
		num_fields() {
			return sizeof(_hextets) / sizeof(hex_type);
		}

		constexpr static addr6_type
		from_hextets(
			addr6_type h1,
			addr6_type h2,
			addr6_type h3,
			addr6_type h4,
			addr6_type h5,
			addr6_type h6,
			addr6_type h7,
			addr6_type h8
		) {
			using namespace stdx::literals;
			return (
				((h1 << 0)   & UINT128_C(0xffff)) |
				((h2 << 16)  & UINT128_C(0xffff0000)) |
				((h3 << 32)  & UINT128_C(0xffff00000000)) |
				((h4 << 48)  & UINT128_C(0xffff000000000000)) |
				((h5 << 64)  & UINT128_C(0xffff0000000000000000)) |
				((h6 << 80)  & UINT128_C(0xffff00000000000000000000)) |
				((h7 << 96)  & UINT128_C(0xffff000000000000000000000000)) |
				((h8 << 112) & UINT128_C(0xffff0000000000000000000000000000)));
		}

		addr6_type addr;
		inet6_type inaddr;
		hex_type _hextets[8];
		bytes<inet6_type> _bytes;

		static_assert(sizeof(addr) == sizeof(inaddr), "bad ipv6_addr size");
		static_assert(sizeof(addr) == sizeof(_hextets), "bad ipv6_addr size");
		static_assert(sizeof(addr) == sizeof(_bytes), "bad ipv6_addr size");
	};

	std::ostream&
	operator<<(std::ostream& out, const ipv6_addr& rhs);

	std::istream&
	operator>>(std::istream& in, ipv6_addr& rhs);

	template<class Addr>
	inline constexpr sockinet6_type
	new_sockinet(family_type f, port_type p, Addr h);

	template<>
	inline constexpr sockinet6_type
	new_sockinet<ipv6_addr>(family_type f, port_type p, ipv6_addr h) {
		return sockinet6_type {
			#if defined(__MACH__)
				   0,
			#endif
				   static_cast<sa_family_type>(f),
				   to_network_format<port_type>(p),
				   0, // flowinfo
				   h.rep(),
				   0 // scope
		};
	}

	template<>
	inline constexpr sockinet6_type
	new_sockinet<ipv4_addr>(family_type f, port_type p, ipv4_addr h) {
		return sockinet6_type {
			#if defined(__MACH__)
				   0,
			#endif
				   static_cast<sa_family_type>(f),
				   to_network_format<port_type>(p),
				   h.rep(),
				   IN6ADDR_ANY_INIT,
				   0 // scope
		};
	}

	union endpoint {

		typedef uint16_t portable_family_type;

		inline constexpr
		endpoint() noexcept {}

		inline constexpr
		endpoint(const endpoint &rhs) noexcept:
		_addr6(rhs._addr6) {}

		inline
		endpoint(const char* h, const port_type p) {
			this->addr(h, p);
		}

		inline constexpr
		endpoint(const ipv4_addr h, const port_type p) noexcept:
		_addr6(new_sockinet(family_type::inet, p, h)) {}

		inline constexpr
		endpoint(const ipv6_addr &h, const port_type p) noexcept:
		_addr6(new_sockinet(family_type::inet6, p, h)) {}

		inline constexpr
		endpoint(const sockinet4_type &rhs) noexcept:
		_addr4(rhs) {}

		inline constexpr
		endpoint(const sockinet6_type &rhs) noexcept:
		_addr6(rhs) {}

		inline constexpr
		endpoint(const sa_type &rhs) noexcept:
		_sockaddr(rhs) {}

		inline constexpr
		endpoint(const endpoint &rhs, const port_type newport) noexcept:
		_addr6(
			rhs.family() == family_type::inet ?
			new_sockinet<ipv4_addr>(
				family_type::inet,
				newport,
				ipv4_addr(rhs._addr6.sin6_flowinfo)
			) :
			new_sockinet<ipv6_addr>(
				family_type::inet6,
				newport,
				ipv6_addr(rhs._addr6.sin6_addr)
			)
		) {}

		inline bool
		operator<(const endpoint& rhs) const noexcept {
			return family() == family_type::inet
			       ? std::make_tuple(sa_family(), addr4(), port4())
			       < std::make_tuple(rhs.sa_family(), rhs.addr4(), rhs.port4())
				   : std::make_tuple(sa_family(), addr6(), port6())
			       < std::make_tuple(rhs.sa_family(), rhs.addr6(), rhs.port6());
		}

		inline constexpr bool
		operator==(const endpoint& rhs) const noexcept {
			return (sa_family() == rhs.sa_family() || sa_family() == 0 ||
			        rhs.sa_family() == 0)
			       && (family() == family_type::inet
			           ? addr4() == rhs.addr4() && port4() == rhs.port4()
					   : addr6() == rhs.addr6() && port6() == rhs.port6());
		}

		inline bool
		operator>=(const endpoint& rhs) const noexcept {
			return !operator<(rhs);
		}

		inline constexpr bool
		operator!=(const endpoint& rhs) const noexcept {
			return !operator==(rhs);
		}

		inline constexpr explicit
		operator bool() const noexcept {
			return sa_family() != 0 && (family() == family_type::inet
			                            ? static_cast<bool>(addr4())
										: static_cast<bool>(addr6()));
		}

		inline constexpr bool
		operator!() const noexcept {
			return !operator bool();
		}

		friend std::ostream&
		operator<<(std::ostream& out, const endpoint& rhs);

		friend std::istream&
		operator>>(std::istream& in, endpoint& rhs);

		friend packetstream&
		operator<<(packetstream& out, const endpoint& rhs);

		friend packetstream&
		operator>>(packetstream& in, endpoint& rhs);

		inline constexpr addr4_type
		address() const noexcept {
			return to_host_format<addr4_type>(this->addr4().rep());
		}

		inline constexpr port_type
		port() const noexcept {
			return to_host_format<port_type>(this->port4());
		}

		inline constexpr family_type
		family() const noexcept {
			return static_cast<family_type>(this->_addr6.sin6_family);
		}

		inline void
		reset() noexcept {
			this->_addr4.sin_family = 0;
			this->_addr4.sin_port = 0;
			this->_addr4.sin_addr.s_addr = 0;
		}

		inline constexpr ipv4_addr
		addr4() const noexcept {
			return ipv4_addr(this->_addr4.sin_addr);
		}

	public:

		inline sa_type*
		sockaddr() noexcept {
			return &this->_sockaddr;
		}

		inline sa_type*
		sockaddr() const noexcept {
			return const_cast<sa_type*>(&this->_sockaddr);
		}

		inline constexpr socklen_type
		sockaddrlen() const noexcept {
			return this->family() == family_type::inet6
			       ? sizeof(sockinet6_type)
				   : sizeof(sockinet4_type);
		}

	private:

		inline constexpr sa_family_type
		sa_family() const noexcept {
			return this->_addr6.sin6_family;
		}

		inline constexpr port_type
		port4() const {
			return this->_addr4.sin_port;
		}

		inline constexpr ipv6_addr
		addr6() const {
			return ipv6_addr(this->_addr6.sin6_addr);
		}

		inline constexpr port_type
		port6() const {
			return this->_addr6.sin6_port;
		}

		void
		addr(const char* host, port_type p);

		sockinet6_type _addr6 = {};
		sockinet4_type _addr4;
		sa_type _sockaddr;

		friend ipv4_addr;
	};

	std::ostream&
	operator<<(std::ostream& out, const endpoint& rhs);

	std::istream&
	operator>>(std::istream& in, endpoint& rhs);

	packetstream&
	operator<<(packetstream& out, const endpoint& rhs);

	packetstream&
	operator>>(packetstream& in, endpoint& rhs);

	static_assert(
		sizeof(endpoint) == sizeof(sockinet6_type),
		"bad endpoint size"
	);
	static_assert(sizeof(port_type) == 2, "bad port_type size");

	ipv4_addr::ipv4_addr(const sa_type& rhs) noexcept:
	inaddr(sys::endpoint(rhs)._addr4.sin_addr)
	{}

	ipv4_addr
	ipv4_addr::from_prefix(prefix_type prefix) noexcept {

		typedef addr4_type T;
		return nbits == prefix
		       ? ipaddr_traits<ipv4_addr>::widearea_mask()
			   : ipv4_addr((T(1) << prefix) - T(1));
	}

}

namespace std {

	template<>
	struct hash<sys::endpoint> {

		typedef size_t result_type;
		typedef sys::endpoint argument_type;

		size_t
		operator()(const sys::endpoint& rhs) const noexcept {
			return size_t(rhs.address()) * size_t(rhs.port());
		}

	};

}

#endif // SYS_ENDPOINT_HH
// vi:ft=cpp
